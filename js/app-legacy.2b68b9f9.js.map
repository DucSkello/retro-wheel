{"version":3,"file":"js/app-legacy.2b68b9f9.js","mappings":"4hDAGaA,SAAb,WACC,WAAYC,EAASC,IAAW,6IAC/B,IAAIC,EAAiB,CACpBC,SAAU,SACVC,QAAS,KACTC,QAAS,KACTC,YAAa,KACbC,YAAa,EACbC,YAAa,EACbC,SAAU,OACVC,cAAe,EACfC,eAAgB,aAChBC,aAAc,GACdC,eAAgB,OAChBC,gBAAiB,aACjBC,cAAe,SACfC,cAAe,SACfC,WAAY,KACZC,cAAe,QACfC,gBAAiB,KACjBC,cAAe,EACfC,UAAW,SACXC,YAAa,KACbC,UAAW,EACXC,gBAAgB,EAChBC,cAAc,EACdC,UAAU,EACVC,aAAc,EACdC,WAAY,KACZC,eAAgB,KAMjB,IAAK,IAAIC,KAAO5B,EACA,MAAXF,GAA2C,qBAAjBA,EAAQ8B,GACrCC,KAAKD,GAAO9B,EAAQ8B,GAEpBC,KAAKD,GAAO5B,EAAe4B,GAK7B,GAAe,MAAX9B,EACH,IAAK,IAAI8B,KAAO9B,EACU,qBAAd+B,KAAKD,KACfC,KAAKD,GAAO9B,EAAQ8B,IAOnBC,KAAK5B,UACR4B,KAAKC,OAASC,SAASC,eAAeH,KAAK5B,UAEvC4B,KAAKC,QAGY,MAAhBD,KAAK3B,UACR2B,KAAK3B,QAAU2B,KAAKC,OAAOG,MAAQ,GAGhB,MAAhBJ,KAAK1B,UACR0B,KAAK1B,QAAU0B,KAAKC,OAAOI,OAAS,GAGb,MAApBL,KAAKzB,cAIJyB,KAAKC,OAAOG,MAAQJ,KAAKC,OAAOI,OACnCL,KAAKzB,YAAcyB,KAAKC,OAAOG,MAAQ,EAAIJ,KAAKR,UAEhDQ,KAAKzB,YAAcyB,KAAKC,OAAOI,OAAS,EAAIL,KAAKR,WAKnDQ,KAAKM,IAAMN,KAAKC,OAAOM,WAAW,QAElCP,KAAKC,OAAS,KACdD,KAAKM,IAAM,QAGZN,KAAKQ,OAAS,KACdR,KAAKM,IAAM,MAKZN,KAAKS,SAAW,IAAIC,MAAM,MAE1B,IAAK,IAAIC,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAGvB,MAAX1C,GAAmBA,EAAQ,aAAqD,qBAA/BA,EAAQ,YAAY0C,EAAI,GAC5EX,KAAKS,SAASE,GAAK,IAAIC,QAAQ3C,EAAQ,YAAY0C,EAAI,IAEvDX,KAAKS,SAASE,GAAK,IAAIC,QAsEzB,GAhEAZ,KAAKa,qBAGmB,OAApBb,KAAKd,aACRc,KAAKd,WAAac,KAAKnB,aAAe,KAMxB,MAAXZ,GAAmBA,EAAQ,cAAgD,qBAAzBA,EAAQ,aAC7D+B,KAAKc,UAAY,IAAIC,UAAU9C,EAAQ,cAEvC+B,KAAKc,UAAY,IAAIC,UAKP,MAAX9C,GAAmBA,EAAQ,SAAsC,qBAApBA,EAAQ,UACxD+B,KAAKgB,KAAO,IAAIC,IAAIhD,EAAQ,UAKR,SAAjB+B,KAAKtB,UAAwC,gBAAjBsB,KAAKtB,UAEA,qBAAzBT,EAAQ,eAClB+B,KAAKV,UAAY,MAIoB,qBAA3BrB,EAAQ,iBAClB+B,KAAKT,YAAc,OAIe,qBAAxBtB,EAAQ,cAClB+B,KAAKL,UAAW,GAImB,qBAAzB1B,EAAQ,eAClB+B,KAAKR,UAAY,GAIO,qBAAdtB,IACVA,GAAY,IAIY,qBAAdA,IACVA,GAAY,GAKC,MAAXD,GAAmBA,EAAQ,iBAAsD,qBAA5BA,EAAQ,gBAChE+B,KAAKkB,aAAe,IAAIC,aAAalD,EAAQ,iBAE7C+B,KAAKkB,aAAe,IAAIC,aAIR,GAAbjD,EACH8B,KAAKoB,KAAKpB,KAAKP,qBACT,GAAqB,gBAAjBO,KAAKtB,SAA4B,CAG3C2C,8BAAgCrB,KAChCsB,sBAAuB,EAEvB,IAAK,IAAIC,EAAI,EAAGA,GAAKvB,KAAKvB,YAAa8C,IACP,OAA3BvB,KAAKS,SAASc,GAAGC,QACpBxB,KAAKS,SAASc,GAAGE,QAAU,IAAIC,MAC/B1B,KAAKS,SAASc,GAAGE,QAAQE,OAASC,oBAClC5B,KAAKS,SAASc,GAAGE,QAAQI,IAAM7B,KAAKS,SAASc,GAAGC,QAtLrD,4KAgMC,WAEC,GAAIxB,KAAKS,SAAU,CAMlB,IAJA,IAAIqB,EAAU,EACVC,EAAS,EAGJpB,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IACR,OAA1BX,KAAKS,SAASE,GAAGqB,OACpBF,GAAW9B,KAAKS,SAASE,GAAGqB,KAC5BD,KAIF,IAAIE,EAAU,IAAMH,EAGhBI,EAAc,EAEdD,EAAU,IACbC,EAAcD,GAAWjC,KAAKvB,YAAcsD,IAK7C,IAAII,EAAgB,EAEpB,IAASxB,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAEtCX,KAAKS,SAASE,GAAGyB,WAAaD,EAG1BnC,KAAKS,SAASE,GAAGqB,KACpBG,GAAiBnC,KAAKS,SAASE,GAAGqB,KAElCG,GAAiBD,EAIlBlC,KAAKS,SAASE,GAAG0B,SAAWF,KAxOhC,yBAgPC,WACKnC,KAAKM,KACRN,KAAKM,IAAIgC,UAAU,EAAG,EAAGtC,KAAKC,OAAOG,MAAOJ,KAAKC,OAAOI,UAlP3D,kBAyPC,SAAKZ,GAEAO,KAAKM,MAEsB,qBAAnBb,EACY,GAAlBA,GACHO,KAAKuC,cAGNvC,KAAKuC,cAIe,SAAjBvC,KAAKtB,UAERsB,KAAKwC,iBAIgB,GAAjBxC,KAAKL,UACRK,KAAKyC,kBAKmB,GAArBzC,KAAKN,cACRM,KAAK0C,gBAEqB,gBAAjB1C,KAAKtB,UAEfsB,KAAK2C,oBAIgB,GAAjB3C,KAAKL,UACRK,KAAKyC,kBAKmB,GAArBzC,KAAKN,cACRM,KAAK0C,iBAIN1C,KAAK0C,eAGgB,GAAjB1C,KAAKL,UACRK,KAAKyC,mBAKkB,qBAAdzC,KAAKgB,MAEU,GAArBhB,KAAKgB,KAAK4B,SAAiB5C,KAAK6C,WAIJ,GAA7B7C,KAAKkB,aAAa4B,SACrB9C,KAAK+C,sBAtTT,sBA8TC,WACC,GAAI/C,KAAKgB,MAAQhB,KAAKgB,KAAKgC,OAO1B,IAFA,IAAIC,EAAa,IAAMjD,KAAKgB,KAAKgC,OAExBE,EAAI,EAAGA,GAAKlD,KAAKgB,KAAKgC,OAAQE,IACtClD,KAAKM,IAAI6C,OAGTnD,KAAKM,IAAIf,YAAcS,KAAKgB,KAAKzB,YACjCS,KAAKM,IAAId,UAAYQ,KAAKgB,KAAKxB,UAC/BQ,KAAKM,IAAIhB,UAAYU,KAAKgB,KAAK1B,UAG/BU,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SAGtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAASJ,EAAID,EAAajD,KAAKrB,gBAGpDqB,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAGxC0B,KAAKM,IAAIiD,YAETvD,KAAKM,IAAIkD,IACRxD,KAAK3B,QACL2B,KAAK1B,QAAU0B,KAAKzB,YAAcyB,KAAKgB,KAAKzC,YAAcyB,KAAKgB,KAAKyC,OACpEzD,KAAKgB,KAAKzC,YACV,EACA,EAAImF,KAAKC,IAGN3D,KAAKgB,KAAK1B,WAAWU,KAAKM,IAAIsD,OAE9B5D,KAAKgB,KAAKzB,aAAaS,KAAKM,IAAIuD,SAEpC7D,KAAKM,IAAIwD,YAtWb,8BA8WC,WAEK9D,KAAKM,MACRN,KAAKM,IAAI6C,OAGTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAAStD,KAAKJ,eACnCI,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAGxC0B,KAAKM,IAAIf,YAAcS,KAAKkB,aAAa3B,YACzCS,KAAKM,IAAId,UAAYQ,KAAKkB,aAAa1B,UAGvCQ,KAAKM,IAAIiD,YACTvD,KAAKM,IAAIyD,OAAO/D,KAAK3B,QAAS2B,KAAK1B,SACnC0B,KAAKM,IAAI0D,OAAOhE,KAAK3B,SAAW2B,KAAKzB,YAAc,GAEnDyB,KAAKM,IAAIuD,SACT7D,KAAKM,IAAIwD,aAlYZ,4BAyYC,WAIC,GAAuB,MAAnB9D,KAAKH,WAAoB,CAG5B,IAAIoE,EAAYjE,KAAK3B,QAAU2B,KAAKH,WAAWQ,OAAS,EACpD6D,EAAWlE,KAAK1B,QAAU0B,KAAKH,WAAWO,MAAQ,EAItDJ,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAAStD,KAAKrB,gBACnCqB,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAExC0B,KAAKM,IAAI6D,UAAUnE,KAAKH,WAAYoE,EAAWC,GAE/ClE,KAAKM,IAAIwD,aA5ZZ,+BAmaC,WAEC,GAAI9D,KAAKM,KAEJN,KAAKS,SAGR,IAAK,IAAIE,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAAK,CAE3C,IAAIyD,EAAMpE,KAAKS,SAASE,GAGxB,GAAIyD,EAAI3C,QAAQpB,OAAQ,CAOvB,IAAI4D,EAAY,EACZC,EAAW,EACXG,EAAa,EACbvE,EAAiB,GAEYA,EAAN,OAAvBsE,EAAItE,eAA0CsE,EAAItE,eAChCE,KAAKF,eAEL,KAAlBA,GAEHmE,EAAYjE,KAAK3B,QAAU+F,EAAI3C,QAAQrB,MAAQ,EAG/C8D,EAAWlE,KAAK1B,QAIhB+F,EAAaD,EAAIhC,WAAa,KAAOgC,EAAI/B,SAAW+B,EAAIhC,YAAc,GAC1C,KAAlBtC,GAEVmE,EAAYjE,KAAK3B,QAGjB6F,EAAWlE,KAAK1B,QAAU8F,EAAI3C,QAAQpB,OAAS,EAI/CgE,EAAaD,EAAIhC,WAAa,KAAOgC,EAAI/B,SAAW+B,EAAIhC,YAAc,GAC1C,KAAlBtC,GAEVmE,EAAYjE,KAAK3B,QAAU+F,EAAI3C,QAAQrB,MAGvC8D,EAAWlE,KAAK1B,QAAU8F,EAAI3C,QAAQpB,OAAS,EAI/CgE,EAAaD,EAAIhC,WAAa,IAAMgC,EAAI/B,SAAW+B,EAAIhC,YAAc,IAIrE6B,EAAYjE,KAAK3B,QAAU+F,EAAI3C,QAAQrB,MAAQ,EAG/C8D,EAAWlE,KAAK1B,QAAU8F,EAAI3C,QAAQpB,OAItCgE,EAAaD,EAAIhC,YAAcgC,EAAI/B,SAAW+B,EAAIhC,YAAc,GAKjEpC,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SAGtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAAStD,KAAKrB,cAAgB0F,IACnDrE,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAGxC0B,KAAKM,IAAI6D,UAAUC,EAAI3C,QAASwC,EAAWC,GAE3ClE,KAAKM,IAAIwD,eAETQ,QAAQC,IAAI,WAAa5D,EAAI,6BAvfnC,0BAigBC,WAEC,GAAIX,KAAKM,KAEJN,KAAKS,SAGR,IAAK,IAAIE,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAAK,CAE3C,IAEIrB,EACAE,EACAD,EAJA6E,EAAMpE,KAAKS,SAASE,GAOIrB,EAAN,OAAlB8E,EAAI9E,UAAgC8E,EAAI9E,UAC3BU,KAAKV,UAEtBU,KAAKM,IAAIhB,UAAYA,EAEOE,EAAN,OAAlB4E,EAAI5E,UAAgC4E,EAAI5E,UAC3BQ,KAAKR,UAEtBQ,KAAKM,IAAId,UAAYA,EAESD,EAAN,OAApB6E,EAAI7E,YAAoC6E,EAAI7E,YAC7BS,KAAKT,YAExBS,KAAKM,IAAIf,YAAcA,GAInBA,GAAeD,KAGlBU,KAAKM,IAAIiD,YAIJvD,KAAKxB,aACTwB,KAAKM,IAAIyD,OAAO/D,KAAK3B,QAAS2B,KAAK1B,SAOpC0B,KAAKM,IAAIkD,IACRxD,KAAK3B,QACL2B,KAAK1B,QACL0B,KAAKzB,YACLyB,KAAKsD,SAASc,EAAIhC,WAAapC,KAAKrB,cAAgB,IACpDqB,KAAKsD,SAASc,EAAI/B,SAAWrC,KAAKrB,cAAgB,KAClD,GAGGqB,KAAKxB,YAORwB,KAAKM,IAAIkD,IACRxD,KAAK3B,QACL2B,KAAK1B,QACL0B,KAAKxB,YACLwB,KAAKsD,SAASc,EAAI/B,SAAWrC,KAAKrB,cAAgB,IAClDqB,KAAKsD,SAASc,EAAIhC,WAAapC,KAAKrB,cAAgB,KACpD,GAIDqB,KAAKM,IAAI0D,OAAOhE,KAAK3B,QAAS2B,KAAK1B,SAMhCgB,GAAWU,KAAKM,IAAIsD,OAEpBrE,GAAaS,KAAKM,IAAIuD,aAnlBhC,6BA6lBC,WAEC,GAAI7D,KAAKM,IAgBR,IAbA,IAAIkE,EACAC,EACAC,EACAC,EACAC,EACAC,EACApB,EACAnE,EACAC,EACAC,EACAsF,EAGKnE,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAAK,CAE3CX,KAAKM,IAAI6C,OAGT,IAAIiB,EAAMpE,KAAKS,SAASE,GAGxB,GAAIyD,EAAIW,KAAM,CAEoBP,EAAN,OAAvBJ,EAAIxF,eAAsCwF,EAAIxF,eAChCoB,KAAKpB,eACQ6F,EAAN,OAArBL,EAAIvF,aAAkCuF,EAAIvF,aAC9BmB,KAAKnB,aACY6F,EAAN,OAAvBN,EAAItF,eAAsCsF,EAAItF,eAChCkB,KAAKlB,eACW6F,EAAN,OAAxBP,EAAIrF,gBAAwCqF,EAAIrF,gBACjCiB,KAAKjB,gBACQ6F,EAAN,OAAtBR,EAAIpF,cAAoCoF,EAAIpF,cAC/BgB,KAAKhB,cACU6F,EAAN,OAAtBT,EAAInF,cAAoCmF,EAAInF,cAC/Be,KAAKf,cACOwE,EAAN,OAAnBW,EAAIlF,WAA8BkF,EAAIlF,WAC5Bc,KAAKd,WACaI,EAAN,OAAtB8E,EAAIjF,cAAoCiF,EAAIjF,cAC/Ba,KAAKb,cACYI,EAAN,OAAxB6E,EAAIhF,gBAAwCgF,EAAIhF,gBACjCY,KAAKZ,gBACQI,EAAN,OAAtB4E,EAAI/E,cAAoC+E,EAAI/E,cAC/BW,KAAKX,cAItByF,EAAc,GAEI,MAAdJ,IAAoBI,GAAeJ,EAAa,KAEpC,MAAZD,IAAkBK,GAAeL,EAAW,OAE9B,MAAdD,IAAoBM,GAAeN,GAGvCxE,KAAKM,IAAI0E,KAAOF,EAChB9E,KAAKM,IAAIhB,UAAYA,EACrBU,KAAKM,IAAIf,YAAcA,EACvBS,KAAKM,IAAId,UAAYA,EAGrB,IAAIyF,EAAQb,EAAIW,KAAKG,MAAM,MAIvBC,EAAa,EAAIV,GAAYQ,EAAMG,OAAS,GAAKX,EAAW,EAI7C,UAAfE,GAAyC,SAAbC,GAAqC,SAAbA,IACvDO,EAAa,GAGd,IAAK,IAAIjC,EAAI,EAAGA,EAAI+B,EAAMG,OAAQlC,IAAK,CAGtC,GAAiB,YAAb2B,GAKH,GAAmB,cAAfF,EAA6B,CACN3E,KAAKM,IAAI+E,UAAlB,SAAbT,EAA2C,QACzB,SAAbA,EAA2C,OAC1B,SAE1B5E,KAAKM,IAAIgF,aAAe,SAGxB,IAAIC,EAAYvF,KAAKsD,SACpBc,EAAI/B,UAAY+B,EAAI/B,SAAW+B,EAAIhC,YAAc,EAAIpC,KAAKrB,cAAgB,GAAK,KAGhFqB,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOkC,GAChBvF,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAEvB,SAAbsG,GAGCtF,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKxB,YAAciF,EAClCzD,KAAK1B,QAAU6G,GAGb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKxB,YAAciF,EAClCzD,KAAK1B,QAAU6G,IAEM,SAAbP,GAENtF,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKzB,YAAckF,EAClCzD,KAAK1B,QAAU6G,GAGb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKzB,YAAckF,EAClCzD,KAAK1B,QAAU6G,KAIb7F,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QACJ2B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCiF,EACDzD,KAAK1B,QAAU6G,GAGb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QACJ2B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCiF,EACDzD,KAAK1B,QAAU6G,IAIlBnF,KAAKM,IAAIwD,eACH,GAAmB,YAAfa,EAA2B,CAErC3E,KAAKM,IAAI+E,UAAY,SAGKrF,KAAKM,IAAIgF,aAAlB,SAAbV,EAA8C,MAC5B,SAAbA,EAA8C,SAC1B,SAEzBW,EAAYnB,EAAI/B,UAAY+B,EAAI/B,SAAW+B,EAAIhC,YAAc,EAAI,IAQrE,GAPAmD,GAAavF,KAAKrB,cAElBqB,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAASiC,IAC9BvF,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAEvB,SAAbsG,EAAsB,IAAIc,EAAO1F,KAAK1B,QAAU0B,KAAKzB,YAAckF,OAClE,GAAiB,SAAbmB,EAA0Bc,EAAO1F,KAAK1B,QAAU0B,KAAKxB,YAAciF,EAG5E,IAAIkC,EAAOlB,EAAWA,EAAW,EAGjC,GAAiB,SAAbG,EAEH,IAAK,IAAIgB,EAAIX,EAAM/B,GAAGkC,OAAS,EAAGQ,GAAK,EAAGA,IACzCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,OAEH,GAAiB,SAAbf,EAEV,IAASgB,EAAI,EAAGA,EAAIX,EAAM/B,GAAGkC,OAAQQ,IACpCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,OAEH,GAAiB,UAAbf,EAAuB,CAIjC,IAAImB,EAAmB,EAEnBd,EAAM/B,GAAGkC,OAAS,IACrBW,EAAoBJ,GAAQV,EAAM/B,GAAGkC,OAAS,GAAM,GAUrD,IAPIM,EACH1F,KAAK1B,QACL0B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCuH,EACAtC,EAEQmC,EAAIX,EAAM/B,GAAGkC,OAAS,EAAGQ,GAAK,EAAGA,IACzCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,EAIV3F,KAAKM,IAAIwD,eACH,GAAmB,UAAfa,EAAyB,CAGnC,IAAIqB,EAAS,EAII,SAAbpB,GAEHoB,EAAShG,KAAKxB,YAAciF,EAC5BzD,KAAKM,IAAIgF,aAAe,OACD,SAAbV,GAEVoB,EAAShG,KAAKzB,YAAckF,EAC5BzD,KAAKM,IAAIgF,aAAe,SAIxBU,GAAUvB,GAAYQ,EAAMG,OAAS,IACd,UAAbR,IAEVoB,EAAShG,KAAKxB,YAAciF,GAAUzD,KAAKzB,YAAcyB,KAAKxB,aAAe,EAC7EwB,KAAKM,IAAIgF,aAAe,UAKzB,IAAIW,EAAe,EACfC,EAAY,EA8ChB,IA3CIjB,EAAM/B,GAAGkC,OAAS,GAErBpF,KAAKM,IAAI+E,UAAY,OAKrBY,EAAoBxB,EAAW,GAAhB,EAGf0B,cAAgB,IAAMH,EAKtBC,GAA8BE,cAK9BC,SAAWH,EAAehB,EAAM/B,GAAGkC,OAGnCc,EAAY9B,EAAIhC,aAAegC,EAAI/B,SAAW+B,EAAIhC,YAAc,EAAIgE,SAAW,KAG/EF,EAAY9B,EAAIhC,YAAcgC,EAAI/B,SAAW+B,EAAIhC,YAAc,EAG/DpC,KAAKM,IAAI+E,UAAY,UAKtBa,GAAalG,KAAKrB,cAIlBuH,GAAa,IAKRN,EAAIX,EAAM/B,GAAGkC,OAAQQ,GAAK,EAAGA,IACjC5F,KAAKM,IAAI6C,OAET0C,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAG5B5F,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAAS4C,IAC9BlG,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAIpCiB,GACHS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAS2B,KAAK1B,QAAU0H,EAASb,GAElE7F,GACHU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAS2B,KAAK1B,QAAU0H,EAASb,GAIpEe,GAAaD,EAEbjG,KAAKM,IAAIwD,gBAMX,GAAmB,cAAfa,EAA6B,CAEN3E,KAAKM,IAAI+E,UAAlB,SAAbT,EAA2C,OACzB,SAAbA,EAA2C,QAC1B,SAG1B5E,KAAKM,IAAIgF,aAAe,SAIpBC,EAAYvF,KAAKsD,SACpBc,EAAI/B,UAAY+B,EAAI/B,SAAW+B,EAAIhC,YAAc,EAAIpC,KAAKrB,cAAgB,IAK3EqB,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOkC,GAChBvF,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAIvB,SAAbsG,GAUCtF,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKxB,YAAciF,EAClCzD,KAAK1B,QAAU6G,GAIb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKxB,YAAciF,EAClCzD,KAAK1B,QAAU6G,IAEM,SAAbP,GAONtF,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKzB,YAAckF,EAClCzD,KAAK1B,QAAU6G,GAIb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QAAU2B,KAAKzB,YAAckF,EAClCzD,KAAK1B,QAAU6G,KASb7F,GACHU,KAAKM,IAAIkF,SACRP,EAAM/B,GACNlD,KAAK3B,QACJ2B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCiF,EACDzD,KAAK1B,QAAU6G,GAIb5F,GACHS,KAAKM,IAAImF,WACRR,EAAM/B,GACNlD,KAAK3B,QACJ2B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCiF,EACDzD,KAAK1B,QAAU6G,IAKlBnF,KAAKM,IAAIwD,eACH,GAAmB,YAAfa,EAA2B,CAMrC3E,KAAKM,IAAI+E,UAAY,SAEKrF,KAAKM,IAAIgF,aAAlB,SAAbV,EAA8C,SAC5B,SAAbA,EAA8C,MAC1B,SAGzBW,EAAYnB,EAAI/B,UAAY+B,EAAI/B,SAAW+B,EAAIhC,YAAc,EAcjE,GAVAmD,GAAavF,KAAKrB,cAGlBqB,KAAKM,IAAI6C,OACTnD,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAASiC,IAC9BvF,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAIvB,SAAbsG,EAA0Bc,EAAO1F,KAAK1B,QAAU0B,KAAKzB,YAAckF,OAClE,GAAiB,SAAbmB,EAA0Bc,EAAO1F,KAAK1B,QAAU0B,KAAKxB,YAAciF,EAKxEkC,EAAOlB,EAAWA,EAAW,EAGjC,GAAiB,SAAbG,EAGH,IAASgB,EAAI,EAAGA,EAAIX,EAAM/B,GAAGkC,OAAQQ,IACpCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,OAEH,GAAiB,SAAbf,EAGV,IAASgB,EAAIX,EAAM/B,GAAGkC,OAAS,EAAGQ,GAAK,EAAGA,IACzCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,OAEH,GAAiB,UAAbf,EAAuB,CAQ7BmB,EAAmB,EAEnBd,EAAM/B,GAAGkC,OAAS,IACrBW,EAAoBJ,GAAQV,EAAM/B,GAAGkC,OAAS,GAAM,GAcrD,IARIM,EACH1F,KAAK1B,QACL0B,KAAKxB,aACJwB,KAAKzB,YAAcyB,KAAKxB,aAAe,EACxCuH,EACAtC,EAGQmC,EAAI,EAAGA,EAAIX,EAAM/B,GAAGkC,OAAQQ,IACpCC,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAExBtG,GAAWU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAEnEnG,GAAaS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAU8G,EAAYO,GAE3EA,GAAQC,EAIV3F,KAAKM,IAAIwD,eACH,GAAmB,UAAfa,EAAyB,CAG/BqB,EAAS,EAII,SAAbpB,GAEHoB,EAAShG,KAAKxB,YAAciF,EAC5BzD,KAAKM,IAAIgF,aAAe,SAIxBU,GAAUvB,GAAYQ,EAAMG,OAAS,IACd,SAAbR,GAEVoB,EAAShG,KAAKzB,YAAckF,EAC5BzD,KAAKM,IAAIgF,aAAe,OACD,UAAbV,IAEVoB,EAAShG,KAAKxB,YAAciF,GAAUzD,KAAKzB,YAAcyB,KAAKxB,aAAe,EAC7EwB,KAAKM,IAAIgF,aAAe,UAKrBW,EAAe,EACfC,EAAY,EA0ChB,IAvCIjB,EAAM/B,GAAGkC,OAAS,GAErBpF,KAAKM,IAAI+E,UAAY,OAKrBY,EAAoBxB,EAAW,GAAhB,EAGf0B,cAAgB,IAAMH,EAKtBC,GAA8BE,cAK9BC,SAAWH,EAAehB,EAAM/B,GAAGkC,OAGnCc,EAAY9B,EAAIhC,aAAegC,EAAI/B,SAAW+B,EAAIhC,YAAc,EAAIgE,SAAW,KAG/EF,EAAY9B,EAAIhC,YAAcgC,EAAI/B,SAAW+B,EAAIhC,YAAc,EAG/DpC,KAAKM,IAAI+E,UAAY,UAKtBa,GAAalG,KAAKrB,cAKbiH,EAAI,EAAGA,EAAIX,EAAM/B,GAAGkC,OAAQQ,IAChC5F,KAAKM,IAAI6C,OAET0C,UAAYZ,EAAM/B,GAAG4C,OAAOF,GAG5B5F,KAAKM,IAAI8C,UAAUpD,KAAK3B,QAAS2B,KAAK1B,SACtC0B,KAAKM,IAAI+C,OAAOrD,KAAKsD,SAAS4C,IAC9BlG,KAAKM,IAAI8C,WAAWpD,KAAK3B,SAAU2B,KAAK1B,SAGpCiB,GACHS,KAAKM,IAAImF,WAAWI,UAAW7F,KAAK3B,QAAS2B,KAAK1B,QAAU0H,EAASb,GAElE7F,GACHU,KAAKM,IAAIkF,SAASK,UAAW7F,KAAK3B,QAAS2B,KAAK1B,QAAU0H,EAASb,GAIpEe,GAAaD,EAEbjG,KAAKM,IAAIwD,UAMZqB,GAAcV,GAKhBzE,KAAKM,IAAIwD,aAvtCb,sBA+tCC,SAASuC,GACR,MAAW,oBAAJA,IAhuCT,uBAsuCC,SAAU1F,EAAGY,GACZvB,KAAK3B,QAAUsC,EACfX,KAAK1B,QAAUiD,IAxuCjB,wBA+uCC,SAAWtD,EAASqI,GAMnB,IAAIC,EAGJ,GAPAC,WAAa,IAAI5F,QAAQ3C,GAGzB+B,KAAKvB,cAImB,qBAAb6H,EAA0B,CAGpC,IAAK,IAAI3F,EAAIX,KAAKvB,YAAakC,EAAI2F,EAAU3F,IAC5CX,KAAKS,SAASE,GAAKX,KAAKS,SAASE,EAAI,GAGtCX,KAAKS,SAAS6F,GAAYE,WAC1BD,EAAaD,OAEbtG,KAAKS,SAAST,KAAKvB,aAAe+H,WAClCD,EAAavG,KAAKvB,YAQnB,OAJAuB,KAAKa,qBAIEb,KAAKS,SAAS8F,KA3wCvB,yBAixCC,SAAYnI,GACPA,GACH4B,KAAK5B,SAAWA,EAChB4B,KAAKC,OAASC,SAASC,eAAeH,KAAK5B,UAEvC4B,KAAKC,SACRD,KAAKM,IAAMN,KAAKC,OAAOM,WAAW,SAGnCP,KAAK5B,SAAW,KAChB4B,KAAKM,IAAM,KACXN,KAAKC,OAAS,QA5xCjB,2BAoyCC,SAAcqG,GAKb,GAAItG,KAAKvB,YAAc,EAAG,CAEzB,GAAwB,qBAAb6H,EAGV,IAAK,IAAI3F,EAAI2F,EAAU3F,EAAIX,KAAKvB,YAAakC,IAC5CX,KAAKS,SAASE,GAAKX,KAAKS,SAASE,EAAI,GAKvCX,KAAKS,SAAST,KAAKvB,kBAAegI,EAIlCzG,KAAKvB,cACLuB,KAAKa,wBAzzCR,4BAi0CC,SAAeF,EAAGY,GACjB,IAAImF,EAAO1G,KAAKC,OAAO0G,wBAEvB,MAAO,CACNhG,EAAG+C,KAAKkD,MAAMjG,EAAI+F,EAAKG,MAAQ7G,KAAKC,OAAOG,MAAQsG,EAAKtG,QACxDmB,EAAGmC,KAAKkD,MAAMrF,EAAImF,EAAKI,KAAO9G,KAAKC,OAAOI,OAASqG,EAAKrG,YAt0C3D,0BA80CC,SAAaM,EAAGY,GACf,IAAIwF,EAAe,KAGfC,EAAgBhH,KAAKiH,mBAAmBtG,EAAGY,GAO/C,OAJsB,OAAlByF,IACHD,EAAe/G,KAAKS,SAASuG,IAGvBD,IAz1CT,gCA+1CC,SAAmBpG,EAAGY,GAMrB,IAMI2F,EACAC,EACAC,EACAC,EACAC,EAVAC,EAAMvH,KAAKwH,eAAe7G,EAAGY,GAkB7BgG,EAAI5G,EAAIX,KAAK3B,SAChB+I,EAAqBG,EAAI5G,EAAIX,KAAK3B,QAClC8I,EAAY,MAEZC,EAAqBpH,KAAK3B,QAAUkJ,EAAI5G,EACxCwG,EAAY,KAGTI,EAAIhG,EAAIvB,KAAK1B,SAChB+I,EAAqBE,EAAIhG,EAAIvB,KAAK1B,QAClC4I,EAAY,MAEZG,EAAqBrH,KAAK1B,QAAUiJ,EAAIhG,EACxC2F,EAAY,KAIb,IAAIO,EAASJ,EAAqBD,EAG9BM,EAA8B,IAApBhE,KAAKiE,KAAKF,GAAiB/D,KAAKC,GAC1CiE,EAAgB,EAuBpB,GApBAN,EAAuB5D,KAAKmE,KAC3BR,EAAqBA,EAAqBD,EAAqBA,GAM/C,KAAbF,GAAiC,KAAbC,EACvBS,EAAgBlE,KAAKoE,MAAM,GAAKJ,GACT,KAAbR,GAAiC,KAAbC,EAC9BS,EAAgBlE,KAAKoE,MAAMJ,EAAS,IACb,KAAbR,GAAiC,KAAbC,EAC9BS,EAAgBlE,KAAKoE,MAAM,GAAKJ,EAAS,KAClB,KAAbR,GAAiC,KAAbC,IAC9BS,EAAgBlE,KAAKoE,MAAMJ,EAAS,MAMX,GAAtB1H,KAAKrB,cAAoB,CAC5B,IAAIoJ,EAAkB/H,KAAKgI,sBAG3BJ,GAAgCG,EAG5BH,EAAgB,IACnBA,EAAgB,IAAMlE,KAAKuE,IAAIL,IAQjC,IAAIM,EAAqB,KAEzB,IAASvH,EAAI,EAAGA,GAAKX,KAAKvB,YAAakC,IAEtC,GAAIiH,GAAiB5H,KAAKS,SAASE,GAAGyB,YAAcwF,GAAiB5H,KAAKS,SAASE,GAAG0B,UAUjFiF,GAAwBtH,KAAKxB,aAAe8I,GAAwBtH,KAAKzB,YAAa,CACzF2J,EAAqBvH,EACrB,MAMH,OAAOuH,IAz8CT,iCA+8CC,WAEC,IAAIC,EAAcnI,KAAKoI,4BAGvB,OAAOpI,KAAKS,SAAS0H,KAp9CvB,uCA29CC,WACC,IAAIE,EAAiB,EACjBC,EAAWtI,KAAKgI,sBAIhBO,EAAgB7E,KAAKkD,MAAM5G,KAAKJ,aAAe0I,GAE/CC,EAAgB,IACnBA,EAAgB,IAAM7E,KAAKuE,IAAIM,IAIhC,IAAK,IAAI5H,EAAI,EAAGA,EAAIX,KAAKS,SAAS2E,OAAQzE,IACzC,GAAI4H,GAAiBvI,KAAKS,SAASE,GAAG,eAAiB4H,GAAiBvI,KAAKS,SAASE,GAAG,YAAa,CACrG0H,EAAiB1H,EACjB,MAIF,OAAO0H,IA/+CT,iCAs/CC,WACC,IAAIG,EAAa,EAEjB,GAAIxI,KAAKgB,KAAM,CACd,IAAIsH,EAAWtI,KAAKgI,sBAIhBO,EAAgB7E,KAAKkD,MAAM5G,KAAKJ,aAAe0I,GAE/CC,EAAgB,IACnBA,EAAgB,IAAM7E,KAAKuE,IAAIM,IAQhC,IAJA,IAAItF,EAAa,IAAMjD,KAAKgB,KAAKgC,OAC7ByF,EAAgB,EAGX9H,EAAI,EAAGA,EAAIX,KAAKgB,KAAKgC,OAAQrC,IAAK,CAC1C,GAAI4H,GAAiBE,GAAiBF,GAAiBE,EAAgBxF,EAAY,CAClFuF,EAAa7H,EACb,MAGD8H,GAAiBxF,EAKc,aAA5BjD,KAAKc,UAAU+D,YAClB2D,IAEIA,EAAaxI,KAAKgB,KAAKgC,SAC1BwF,EAAa,IAKhB,OAAOA,IA7hDT,iCAmiDC,WACC,IAAIF,EAAWtI,KAAKrB,cAGpB,GAAI2J,GAAY,GACf,GAAIA,EAAW,IAAK,CAEnB,IAAII,EAAehF,KAAKkD,MAAM0B,EAAW,KAGzCA,GAAsB,IAAMI,OAEvB,CAGN,GAAIJ,GAAY,IAAK,CAChBI,EAAehF,KAAKiF,KAAKL,EAAW,KAExCA,GAAsB,IAAMI,EAG7BJ,EAAW,IAAMA,EAGlB,OAAOA,IA3jDT,4BAikDC,WACC,GAAItI,KAAKc,UAAW,CAEnBd,KAAK4I,mBAILvH,8BAAgCrB,KAGhC,IAAI6I,EAAa,IAAInI,MAAM,MAC3BmI,EAAW7I,KAAKc,UAAUgI,cAAgB9I,KAAKc,UAAUiI,cACzDF,EAAW,QAAU7I,KAAKc,UAAUkI,KACpCH,EAAW,UAAY7I,KAAKc,UAAUmI,OACtCJ,EAAW,QAAU7I,KAAKc,UAAUoI,OACpCL,EAAW,YAAcM,sBACzBN,EAAW,cAAgBO,sBAI3BpJ,KAAKqJ,MAAQC,kCAAAA,GAAAA,GAAYtJ,KAAMA,KAAKc,UAAUyI,SAAUV,MArlD3D,2BA4lDC,SAAcW,GAITnI,gCACHA,8BAA8BgI,MAAMI,OAGpCL,sBAAsBI,IAIvBnI,8BAAgCrB,OAxmDlC,4BA8mDC,WACKA,KAAKqJ,OACRrJ,KAAKqJ,MAAMK,UAhnDd,6BAunDC,WACK1J,KAAKqJ,OACRrJ,KAAKqJ,MAAMM,SAznDd,8BAkoDC,WACK3J,KAAKc,YAEmB,eAAvBd,KAAKc,UAAU8I,MAElB5J,KAAKc,UAAUgI,aAAe,gBAEF,MAAxB9I,KAAKc,UAAU+I,QAClB7J,KAAKc,UAAU+I,MAAQ,GAGK,MAAzB7J,KAAKc,UAAUmI,SAClBjJ,KAAKc,UAAUmI,QAAU,GAGG,MAAzBjJ,KAAKc,UAAUoI,SAClBlJ,KAAKc,UAAUoI,OAAS,mBAGE,MAAvBlJ,KAAKc,UAAUkI,OAClBhJ,KAAKc,UAAUkI,MAAO,GAIvBhJ,KAAKc,UAAUiI,cAAuC,IAAvB/I,KAAKc,UAAU+I,MAGd,kBAA5B7J,KAAKc,UAAU+D,YAClB7E,KAAKc,UAAUiI,cAAgB,EAAI/I,KAAKc,UAAUiI,gBAElB,cAAvB/I,KAAKc,UAAU8I,MAEzB5J,KAAKc,UAAUgI,aAAe,gBAEF,MAAxB9I,KAAKc,UAAU+I,QAClB7J,KAAKc,UAAU+I,MAAQ,GAGK,MAAzB7J,KAAKc,UAAUmI,SAClBjJ,KAAKc,UAAUmI,OAAS,GAGI,MAAzBjJ,KAAKc,UAAUoI,SAClBlJ,KAAKc,UAAUoI,OAAS,kBAGO,MAA5BlJ,KAAKc,UAAUgJ,UAElB9J,KAAKc,UAAUiJ,WAAarG,KAAKkD,MAAsB,IAAhBlD,KAAKsG,UAK5ChK,KAAKc,UAAUiJ,WAAa,IAAM/J,KAAKc,UAAUgJ,UAAY9J,KAAKJ,aAGxC,MAAvBI,KAAKc,UAAUkI,OAClBhJ,KAAKc,UAAUkI,MAAO,GAIvBhJ,KAAKc,UAAUiI,cAAuC,IAAvB/I,KAAKc,UAAU+I,MAEd,kBAA5B7J,KAAKc,UAAU+D,WAClB7E,KAAKc,UAAUiI,cAAgB,EAAI/I,KAAKc,UAAUiI,cAIlD/I,KAAKc,UAAUiI,eAAiB,IAAM/I,KAAKc,UAAUiJ,YAGrD/J,KAAKc,UAAUiI,eAAiB/I,KAAKc,UAAUiJ,YAEf,eAAvB/J,KAAKc,UAAU8I,MAKzB5J,KAAKc,UAAUgI,aAAe,gBAEF,MAAxB9I,KAAKc,UAAU+I,QAClB7J,KAAKc,UAAU+I,MAAQ,GAGK,MAAzB7J,KAAKc,UAAUmI,SAClBjJ,KAAKc,UAAUmI,OAAS,GAGI,MAAzBjJ,KAAKc,UAAUoI,SAClBlJ,KAAKc,UAAUoI,OAAS,oBAGE,MAAvBlJ,KAAKc,UAAUkI,OAClBhJ,KAAKc,UAAUkI,MAAO,GAGS,MAA5BhJ,KAAKc,UAAUgJ,UAClB9J,KAAKc,UAAUiJ,WAAa,EAK5B/J,KAAKc,UAAUiJ,WAAa,IAAM/J,KAAKc,UAAUgJ,UAIlD9J,KAAKc,UAAUiI,cAAuC,IAAvB/I,KAAKc,UAAU+I,MAEd,kBAA5B7J,KAAKc,UAAU+D,WAClB7E,KAAKc,UAAUiI,cAAgB,EAAI/I,KAAKc,UAAUiI,cAIlD/I,KAAKc,UAAUiI,eAAiB,IAAM/I,KAAKc,UAAUiJ,YAGrD/J,KAAKc,UAAUiI,eAAiB/I,KAAKc,UAAUiJ,YAEtC/J,KAAKc,UAAU8I,QAxvD7B,iCAmwDC,SAAoB5C,GACnB,IAAI8C,EAAY,EAEhB,GAAI9C,EACH,GAA4C,qBAAjChH,KAAKS,SAASuG,GAAgC,CACxD,IAAI5E,EAAapC,KAAKS,SAASuG,GAAe5E,WAC1CC,EAAWrC,KAAKS,SAASuG,GAAe3E,SACxC4H,EAAQ5H,EAAWD,EAAa,EAEhC6H,EAAQ,EACXH,EAAY1H,EAAa,EAAIsB,KAAKkD,MAAMlD,KAAKsG,SAAWC,GAExD3F,QAAQC,IAAI,uEAGbD,QAAQC,IAAI,WAAayC,EAAgB,mBAG1C1C,QAAQC,IAAI,gCAGb,OAAOuF,MAxxDT,KA+xDa7I,KAAb,mIACC,WAAYhD,IAAS,6IACpB,IAAIE,EAAiB,CACpByE,SAAS,EACTI,OAAQ,GACRzE,YAAa,EACbe,UAAW,OACXC,YAAa,QACbC,UAAW,EACXiE,OAAQ,GAKT,IAAK,IAAI1D,KAAO5B,EACA,MAAXF,GAA2C,qBAAjBA,EAAQ8B,GAAsBC,KAAKD,GAAO9B,EAAQ8B,GAC3EC,KAAKD,GAAO5B,EAAe4B,GAIjC,GAAe,MAAX9B,EACH,IAAK,IAAI8B,KAAO9B,EACU,qBAAd+B,KAAKD,KACfC,KAAKD,GAAO9B,EAAQ8B,OASZgB,WAAb,mIACC,WAAY9C,IAAS,6IAEpB,IAAIE,EAAiB,CACpByL,KAAM,cACN/E,UAAW,YACXiE,aAAc,KACdC,cAAe,KACfQ,SAAU,GACVP,MAAM,EACNC,OAAQ,KACRC,OAAQ,KACRY,UAAW,KACXD,MAAO,KACPpK,eAAgB,KAChByK,iBAAkB,KAClBC,eAAgB,KAChBC,cAAe,KACfC,cAAe,KACfC,aAAc,WAKf,IAAK,IAAIvK,KAAO5B,EACA,MAAXF,GAA2C,qBAAjBA,EAAQ8B,GAAsBC,KAAKD,GAAO9B,EAAQ8B,GAC3EC,KAAKD,GAAO5B,EAAe4B,GAIjC,GAAe,MAAX9B,EACH,IAAK,IAAI8B,KAAO9B,EACU,qBAAd+B,KAAKD,KACfC,KAAKD,GAAO9B,EAAQ8B,OASZa,QAAb,WACC,WAAY3C,IAAS,6IAGpB,IAAIE,EAAiB,CACpB6D,KAAM,KACN+C,KAAM,GACNzF,UAAW,KACXC,YAAa,KACbC,UAAW,KACXZ,eAAgB,KAChBC,aAAc,KACdC,eAAgB,KAChBC,gBAAiB,KACjBC,cAAe,KACfC,cAAe,KACfC,WAAY,KACZC,cAAe,KACfC,gBAAiB,KACjBC,cAAe,KACfmC,MAAO,KACP1B,eAAgB,KAChB2B,QAAS,MAKV,IAAK,IAAI1B,KAAO5B,EACA,MAAXF,GAA2C,qBAAjBA,EAAQ8B,GAAsBC,KAAKD,GAAO9B,EAAQ8B,GAC3EC,KAAKD,GAAO5B,EAAe4B,GAKjC,GAAe,MAAX9B,EACH,IAAK,IAAI8B,KAAO9B,EACU,qBAAd+B,KAAKD,KACfC,KAAKD,GAAO9B,EAAQ8B,IAQvBC,KAAKoC,WAAa,EAClBpC,KAAKqC,SAAW,EA9ClB,qKAoDC,SAAYb,EAAO1B,GAElBE,KAAKwB,MAAQA,EACbxB,KAAKyB,QAAU,KAGX3B,IACHE,KAAKF,eAAiBA,GAIvBwB,sBAAuB,EACvBtB,KAAKyB,QAAU,IAAIC,MACnB1B,KAAKyB,QAAQE,OAASC,oBACtB5B,KAAKyB,QAAQI,IAAM7B,KAAKwB,UAlE1B,KA0EaL,cAAb,mIACC,WAAYlD,IAAS,6IACpB,IAAIE,EAAiB,CACpB2E,SAAS,EACTvD,YAAa,MACbC,UAAW,GAKZ,IAAK,IAAIO,KAAO5B,EACA,MAAXF,GAA2C,qBAAjBA,EAAQ8B,GACrCC,KAAKD,GAAO9B,EAAQ8B,GAEpBC,KAAKD,GAAO5B,EAAe4B,MAS/B,SAASwK,yBAAyBC,GACjC,IAAIC,EAAU,EAEd,GAAID,EAAe,GAAKA,GAAgB,IAAK,CAC5C,IAAIE,EAAUF,EAAe,IAC7BC,EAAU,IAAMC,EAGjB,OAAOD,EAOR,SAAStB,wBACR,GAAI9H,8BAA+B,CAE4B,GAA1DA,8BAA8BP,UAAUrB,gBAC3C4B,8BAA8Bf,IAAIgC,UACjC,EACA,EACAjB,8BAA8BpB,OAAOG,MACrCiB,8BAA8BpB,OAAOI,QAIvC,IAAI8J,eAAiB9I,8BAA8BP,UAAUqJ,eACzDC,cAAgB/I,8BAA8BP,UAAUsJ,cAGtC,MAAlBD,iBAE2B,oBAAnBA,eACVA,iBAEAQ,KAAKR,iBAKP9I,8BAA8BD,MAAK,GAGd,MAAjBgJ,gBAE0B,oBAAlBA,cACVA,gBAEAO,KAAKP,gBAMH/I,8BAA8BP,UAAUuJ,eAC3CO,wBASH,SAASA,uBAEuE,GAA3EvJ,8BAA8BwJ,eAAe,6BAChDxJ,8BAA8ByJ,wBAA0B,GAGzD,IAAIT,cAAgBhJ,8BAA8BP,UAAUuJ,cACxDU,qBAAuB,EAK1BA,qBAF2D,OAAxD1J,8BAA8BP,UAAUwJ,aAEpBjJ,8BAA8B2J,sBAI9B3J,8BAA8B+G,4BAIlD2C,sBAAwB1J,8BAA8ByJ,0BAE5B,oBAAlBT,cACVA,gBAEAM,KAAKN,eAINhJ,8BAA8ByJ,wBAA0BC,sBAO1D,IAAI1J,8BAAgC,KAEpC,SAAS+H,sBAAsBI,aAG9B,GAAmB,GAAfA,YAAsB,CACzB,IAAIyB,SAAW5J,8BAA8BP,UAAUoJ,iBAEvC,MAAZe,WAEqB,oBAAbA,SAEVA,SAAS5J,8BAA8B6J,uBAEvCP,KAAKM,YAUT,IAAI3J,sBAAuB,EAE3B,SAASM,sBAER,GAA4B,GAAxBN,qBAA+B,CAKlC,IAHA,IAAI6J,EAAyB,EAGpBjI,EAAI,EAAGA,GAAK7B,8BAA8B5C,YAAayE,IAIT,MAArD7B,8BAA8BZ,SAASyC,GAAGzB,SAC1CJ,8BAA8BZ,SAASyC,GAAGzB,QAAQpB,QAElD8K,IAKEA,GAA0B9J,8BAA8B5C,cAE3D6C,sBAAuB,EACvBD,8BAA8BD,W,mEClmE7BgK,EAAS,WAAa,IAAIC,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACA,EAAG,mBAAmBA,EAAG,MAAM,CAACE,MAAM,CAAC,GAAK,QAAQ,CAACF,EAAG,mBAAmB,IAAI,IACrLG,EAAkB,GCDlB,EAAS,WAAa,IAAIN,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,GAAK,QAAQ,CAACF,EAAG,MAAM,CAACI,YAAY,gCAAgC,CAACJ,EAAG,MAAM,CAACI,YAAY,qCAAqC,CAACJ,EAAG,mBAAmB,GAAGA,EAAG,MAAM,CAACI,YAAY,sBAAsB,CAACJ,EAAG,gBAAgB,QACvU,EAAkB,GCDlB,EAAS,WAAa,IAAIH,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,UAAU,CAACI,YAAY,gBAAgB,CAACJ,EAAG,MAAM,CAACI,YAAY,kDAAkD,CAAEP,EAAIQ,iBAAiBzG,OAAS,EAAGoG,EAAG,MAAM,CAACA,EAAG,MAAM,CAACI,YAAY,oBAAoB,CAACJ,EAAG,MAAM,CAACI,YAAY,iBAAiB,CAACP,EAAIS,GAAG,GAAGN,EAAG,MAAM,CAACI,YAAY,kBAAkB,CAAGP,EAAIU,cAAiBV,EAAIW,cAAuKX,EAAIY,KAA5JT,EAAG,IAAI,CAACI,YAAY,eAAeF,MAAM,CAAC,KAAO,KAAKQ,GAAG,CAAC,MAAQ,SAASC,GAAgC,OAAxBA,EAAOC,iBAAwBf,EAAIgB,eAAe,CAAChB,EAAIiB,GAAG,iBAA2BjB,EAAiB,cAAEG,EAAG,MAAM,CAACI,YAAY,0BAA0BF,MAAM,CAAC,GAAK,mBAAmB,CAACF,EAAG,MAAM,CAACE,MAAM,CAAC,KAAO,QAAQa,KAAK,QAAQ,CAACf,EAAG,IAAI,CAACI,YAAY,gBAAgBF,MAAM,CAAC,KAAO,IAAIQ,GAAG,CAAC,MAAQ,SAASC,GAAgC,OAAxBA,EAAOC,iBAAwBf,EAAImB,eAAe,CAAChB,EAAG,IAAI,CAACI,YAAY,iBAAiBJ,EAAG,KAAK,CAACH,EAAIiB,GAAG,UAAUjB,EAAIoB,GAAGpB,EAAIqB,WAAW,2BAA2BrB,EAAIY,OAAOT,EAAG,MAAM,CAACI,YAAY,uBAAuB,CAACP,EAAIiB,GAAG,wCAC3hC,EAAkB,CAAC,WAAa,IAAIjB,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACI,YAAY,kBAAkB,CAACJ,EAAG,SAAS,CAACE,MAAM,CAAC,GAAK,SAAS,MAAQ,MAAM,OAAS,QAAQ,CAACF,EAAG,IAAI,CAACmB,YAAY,CAAC,SAAS,UAAUjB,MAAM,CAAC,MAAQ,WAAW,CAACL,EAAIiB,GAAG,iF,gECuC/R,GACA,CACAnN,cAAAA,OACAG,UAAAA,WAEA,CACAH,cAAAA,OACAG,UAAAA,WAEA,CACAH,cAAAA,UACAG,UAAAA,SAMA,GACAsN,KAAAA,iBACAC,KAFA,WAGA,OACAd,cAAAA,EACAe,SAAAA,KACAC,eAAAA,EACAf,eAAAA,EACAgB,gBAAAA,CACAnO,aAAAA,GACAoO,aAAAA,IACAzO,YAAAA,GACAgB,UAAAA,EACAsB,UAAAA,CACA8I,KAAAA,cACAL,SAAAA,OAKA2D,QAAAA,CACAC,UADA,WAEA,uBAEAX,UAJA,WAKA,uBAEAH,UAPA,WAOA,WAEA,GADA,kBACA,wBACA,+BACA,sBACA,0CACA,sBADA,IAEA5N,YAAAA,KAAAA,iBAAAA,OACAgC,SAAAA,KAAAA,iBACAK,UAAAA,CACA8I,KAAAA,aACAL,SAAAA,EACAM,MAAAA,GACAK,iBAAAA,KAAAA,iBAMA,6DACA,wEAEA,oCACA,iDACA,eAEA,+BACA,wBAGAkD,aArCA,SAqCAC,GAEA,IADA,QACA,aACA,YACAC,EAAAA,EAAAA,EACA,MAGA,aAEAC,WA/CA,WAgDA,0CACA,sBADA,IAEA9O,YAAAA,KAAAA,iBAAAA,OACAgC,SAAAA,KAAAA,iBACAK,UAAAA,CACA8I,KAAAA,aACAL,SAAAA,EACAM,MAAAA,OAIA,oBACA,gCAGA,8BACA,qBACA,uBAEA2D,SAnEA,WAoEA,qBACA,kBACA,sBAEAC,aAxEA,SAwEAC,GACA,sBACA,kBAEAC,UA5EA,cAgFAC,UAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,IACAC,EAAAA,EAAAA,IAAAA,CAAAA,aADA,IAEAhC,iBAFA,WAEA,WACA,kCAEA,aACAiC,QAAA,kCACAC,KAAA,cACA,yBACA,mBADA,IAEAhJ,KAAAA,EAAAA,KACAiJ,OAAAA,EAAAA,OACAC,UAAAA,EAAAA,kBAKAC,MAAAA,CACArC,iBADA,WAEA,kBACA,mBAGAsC,QA3HA,WA4HA,oBCrL4R,I,UCQxRC,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAeA,EAAiB,QCnB5B,EAAS,WAAa,IAAI/C,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,UAAU,CAACA,EAAG,MAAM,CAACI,YAAY,mBAAmB,CAACJ,EAAG,OAAO,CAACI,YAAY,kDAAkD,CAACJ,EAAG,MAAM,CAACI,YAAY,QAAQ,CAACJ,EAAG,QAAQ,CAACI,YAAY,6CAA6CF,MAAM,CAAC,IAAM,aAAa,CAACL,EAAIiB,GAAG,6BAA6Bd,EAAG,MAAM,CAACI,YAAY,iBAAiB,CAACJ,EAAG,MAAM,CAACI,YAAY,aAAa,CAACJ,EAAG,QAAQ,CAAC6C,WAAW,CAAC,CAACzB,KAAK,QAAQ0B,QAAQ,UAAUC,MAAOlD,EAAe,YAAEmD,WAAW,gBAAgB5C,YAAY,6HAA6HF,MAAM,CAAC,GAAK,WAAW,KAAO,OAAO,YAAc,iBAAiB+C,SAAS,CAAC,MAASpD,EAAe,aAAGa,GAAG,CAAC,MAAQ,SAASC,GAAWA,EAAOuC,OAAOC,YAAqBtD,EAAIuD,YAAYzC,EAAOuC,OAAOH,aAAY/C,EAAG,MAAM,CAACI,YAAY,aAAa,CAACJ,EAAG,SAAS,CAACI,YAAY,mKAAmKF,MAAM,CAAC,SAA+B,KAApBL,EAAIuD,aAAoB1C,GAAG,CAAC,MAAQ,SAASC,GAAgC,OAAxBA,EAAOC,iBAAwBf,EAAIwD,gBAAgB,CAACxD,EAAIiB,GAAG,6BAA6Bd,EAAG,MAAM,CAACI,YAAY,oBAAoB,CAACJ,EAAG,MAAM,CAACI,YAAY,yEAAyE,CAACP,EAAIS,GAAG,GAAGT,EAAIyD,GAAIzD,EAAW,SAAE,SAAS0D,GAAQ,OAAOvD,EAAG,MAAM,CAACzL,IAAIgP,EAAOf,OAAOpC,YAAY,2BAA2B,CAACJ,EAAG,MAAM,CAACI,YAAY,6CAA6C,CAACJ,EAAG,MAAM,CAACH,EAAIiB,GAAGjB,EAAIoB,GAAGsC,EAAOnC,SAASpB,EAAG,MAAM,CAACA,EAAG,QAAQ,CAAC6C,WAAW,CAAC,CAACzB,KAAK,QAAQ0B,QAAQ,UAAUC,MAAOQ,EAAgB,UAAEP,WAAW,qBAAqB5C,YAAY,6PAA6PF,MAAM,CAAC,KAAO,YAAY+C,SAAS,CAAC,QAAU/N,MAAMsO,QAAQD,EAAOd,WAAW5C,EAAI4D,GAAGF,EAAOd,UAAU,OAAO,EAAGc,EAAgB,WAAG7C,GAAG,CAAC,MAAQ,SAASC,GAAQ,OAAOd,EAAI6D,yBAAyBH,GAASA,EAAOd,YAAY,OAAS,SAAS9B,GAAQ,IAAIgD,EAAIJ,EAAOd,UAAUmB,EAAKjD,EAAOuC,OAAOW,IAAID,EAAKE,QAAuB,GAAG5O,MAAMsO,QAAQG,GAAK,CAAC,IAAII,EAAI,KAAKC,EAAInE,EAAI4D,GAAGE,EAAII,GAAQH,EAAKE,QAASE,EAAI,GAAInE,EAAIoE,KAAKV,EAAQ,YAAaI,EAAIO,OAAO,CAACH,KAAaC,GAAK,GAAInE,EAAIoE,KAAKV,EAAQ,YAAaI,EAAIQ,MAAM,EAAEH,GAAKE,OAAOP,EAAIQ,MAAMH,EAAI,UAAYnE,EAAIoE,KAAKV,EAAQ,YAAaM,SAAY7D,EAAG,MAAM,CAACA,EAAG,SAAS,CAACI,YAAY,mMAAmMM,GAAG,CAAC,MAAQ,SAASC,GAAgC,OAAxBA,EAAOC,iBAAwBf,EAAIuE,aAAab,MAAW,CAAC1D,EAAIiB,GAAG,mBAAkB,QACr7F,EAAkB,CAAC,WAAa,IAAIjB,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACI,YAAY,iCAAiC,CAACJ,EAAG,MAAM,CAACH,EAAIiB,GAAG,UAAUd,EAAG,MAAM,CAACH,EAAIiB,GAAG,cAAcd,EAAG,MAAM,CAACH,EAAIiB,GAAG,mBCoE7O,GACAM,KAAAA,cACAC,KAFA,WAGA,OACA+B,YAAAA,KAGA1B,SAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,IACA2C,EAAAA,EAAAA,IAAAA,CACA,cACA,gBACA,mBAJA,IAMAhB,WANA,WAOA,OACAjC,KAAAA,KAAAA,YACAqB,WAAAA,GAEA,oBACA,qBAEAiB,yBAdA,SAcAH,EAAAR,GACAQ,EAAAA,UAAAA,EACA,uBAEAa,aAlBA,SAkBAb,GACAzK,QAAAA,IAAAA,SACA,yBAGAsJ,UAAAA,EAAAA,EAAAA,GAAAA,IACAC,EAAAA,EAAAA,IAAAA,CAAAA,aAEAK,MAAAA,ICtGgR,ICO5Q,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAe,EAAiB,QCAhC,GACAtB,KAAAA,iBACAC,KAFA,WAGA,UAIAiD,WAAAA,CACAC,eAAAA,EACAC,YAAAA,GAEA7B,QAXA,aAcAP,SAAAA,GAGAV,QAAAA,GAGAgB,MAAAA,ICtCmR,ICQ/Q,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,KACA,MAIF,EAAe,EAAiB,QCnB5B,EAAS,WAAa,IAAI7C,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACI,YAAY,iEAAiE,CAACJ,EAAG,MAAM,CAACI,YAAY,iEAAiE,CAACP,EAAIS,GAAG,GAAGN,EAAG,MAAM,CAACI,YAAY,mBAAmB,CAACJ,EAAG,SAAS,CAACI,YAAY,oOAAoOF,MAAM,CAAC,KAAO,WAAW,CAACL,EAAIiB,GAAG,sBAAsBd,EAAG,SAAS,CAACI,YAAY,mNAAmNF,MAAM,CAAC,uBAAuB,gBAAgB,KAAO,SAAS,gBAAgB,gBAAgB,gBAAgB,UAAU,CAACF,EAAG,OAAO,CAACI,YAAY,WAAW,CAACP,EAAIiB,GAAG,oBAAoBd,EAAG,MAAM,CAACI,YAAY,UAAUF,MAAM,CAAC,KAAO,eAAe,QAAU,YAAY,MAAQ,+BAA+B,CAACF,EAAG,OAAO,CAACE,MAAM,CAAC,YAAY,UAAU,EAAI,kJAAkJ,YAAY,eAAeF,EAAG,MAAM,CAACI,YAAY,iBAAiBF,MAAM,CAAC,KAAO,eAAe,QAAU,YAAY,MAAQ,+BAA+B,CAACF,EAAG,OAAO,CAACE,MAAM,CAAC,YAAY,UAAU,EAAI,qMAAqM,YAAY,mBAAmBL,EAAIS,GAAG,QACpwD,EAAkB,CAAC,WAAa,IAAIT,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,IAAI,CAACI,YAAY,oBAAoBF,MAAM,CAAC,KAAO,yBAAyB,CAACF,EAAG,OAAO,CAACI,YAAY,uEAAuE,CAACP,EAAIiB,GAAG,mBAAmB,WAAa,IAAIjB,EAAIrL,KAASsL,EAAGD,EAAIE,eAAmBC,EAAGH,EAAII,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACI,YAAY,0EAA0EF,MAAM,CAAC,GAAK,kBAAkB,CAACF,EAAG,KAAK,CAACI,YAAY,iFAAiF,CAACJ,EAAG,KAAK,CAACA,EAAG,IAAI,CAACI,YAAY,gHAAgHF,MAAM,CAAC,KAAO,IAAI,eAAe,SAAS,CAACL,EAAIiB,GAAG,YAAYd,EAAG,KAAK,CAACA,EAAG,IAAI,CAACI,YAAY,4RAA4RF,MAAM,CAAC,KAAO,MAAM,CAACL,EAAIiB,GAAG,aAAad,EAAG,KAAK,CAACA,EAAG,IAAI,CAACI,YAAY,4RAA4RF,MAAM,CAAC,KAAO,MAAM,CAACL,EAAIiB,GAAG,gBAAgBd,EAAG,KAAK,CAACA,EAAG,IAAI,CAACI,YAAY,4RAA4RF,MAAM,CAAC,KAAO,MAAM,CAACL,EAAIiB,GAAG,qBCkCn1D,GACAM,KAAAA,mBCpC2Q,ICOvQ,GAAY,OACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIF,EAAe,EAAiB,QCLhC,GACAA,KAAAA,MACAkD,WAAAA,CACAG,eAAAA,EACAC,gBAAAA,ICjBsP,ICQlP,GAAY,OACd,EACA9E,EACAO,GACA,EACA,KACA,KACA,MAIF,EAAe,EAAiB,Q,eChBhCwE,EAAAA,EAAAA,IAAQC,EAAAA,IAER,IAAMC,EAAQ,CACZC,QAAS,IAGLC,EAAY,CAChBC,YADgB,SACHH,EAAO9B,GAClB,IAAMP,EAASyC,KAAKC,MACd3B,EAAS,CACbf,OAAAA,EACApB,KAAM2B,EAAM3B,KACZqB,UAAWM,EAAMN,WAEnBoC,EAAMC,QAAQK,KAAK5B,IAGrB6B,cAXgB,SAWDP,EAAOtB,GACpB,IAAM8B,EAAcR,EAAMC,QACvBQ,WAAU,SAAAC,GAAW,OAAIA,EAAY/C,SAAWe,EAAOf,UAC1DqC,EAAMC,QAAQU,OAAOH,EAAa,EAAG9B,IAGvCkC,cAjBgB,SAiBDZ,EAAOtB,GACpB,IAAM8B,EAAcR,EAAMC,QACvBQ,WAAU,SAAAC,GAAW,OAAIA,EAAY/C,SAAWe,EAAOf,UAC1DqC,EAAMC,QAAQU,OAAOH,EAAa,KAItC,MAAmBT,EAAAA,GAAAA,MAAW,CAC5BC,MAAAA,EACAE,UAAAA,I,gBChCFJ,EAAAA,EAAAA,IAAQe,EAAAA,GAKR,IAAMC,EAAS,IAAID,EAAAA,EAAU,CAC3BE,KAAM,UACNC,KAAMC,EACNC,OAAQ,CACN,CAAEC,KAAM,IAAKpD,UAAWqD,GACxB,CAAED,KAAM,UAAWpD,UAAW6B,MAIlC,I,QCVAE,EAAAA,EAAAA,OAAAA,eAA2B,EAE3B,IAAIA,EAAAA,EAAI,CACNuB,GAAI,OACJP,OAAAA,EACAQ,MAAAA,EACAC,SAAU,SACV9B,WAAY,CAAE2B,IAAAA,OCbZI,yBAA2B,GAG/B,SAASC,oBAAoBC,GAE5B,IAAIC,EAAeH,yBAAyBE,GAC5C,QAAqBtL,IAAjBuL,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,yBAAyBE,GAAY,CACjDI,GAAIJ,EACJK,QAAQ,EACRH,QAAS,IAUV,OANAI,oBAAoBN,GAAUG,EAAQA,EAAOD,QAASH,qBAGtDI,EAAOE,QAAS,EAGTF,EAAOD,QAIfH,oBAAoBQ,EAAID,oB,WC5BxB,IAAIE,EAAW,GACfT,oBAAoBU,EAAI,SAAS9K,EAAQ+K,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAAS3P,EAAI,EAAGA,EAAIqP,EAASnN,OAAQlC,IAAK,CACrCuP,EAAWF,EAASrP,GAAG,GACvBwP,EAAKH,EAASrP,GAAG,GACjByP,EAAWJ,EAASrP,GAAG,GAE3B,IAJA,IAGI4P,GAAY,EACPC,EAAI,EAAGA,EAAIN,EAASrN,OAAQ2N,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAaK,OAAOC,KAAKnB,oBAAoBU,GAAGU,OAAM,SAASnT,GAAO,OAAO+R,oBAAoBU,EAAEzS,GAAK0S,EAASM,OAC3JN,EAASzB,OAAO+B,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbP,EAASvB,OAAO9N,IAAK,GACrB,IAAIiQ,EAAIT,SACEjM,IAAN0M,IAAiBzL,EAASyL,IAGhC,OAAOzL,EAzBNiL,EAAWA,GAAY,EACvB,IAAI,IAAIzP,EAAIqP,EAASnN,OAAQlC,EAAI,GAAKqP,EAASrP,EAAI,GAAG,GAAKyP,EAAUzP,IAAKqP,EAASrP,GAAKqP,EAASrP,EAAI,GACrGqP,EAASrP,GAAK,CAACuP,EAAUC,EAAIC,I,cCJ/Bb,oBAAoBsB,EAAI,SAASlB,GAChC,IAAImB,EAASnB,GAAUA,EAAOoB,WAC7B,WAAa,OAAOpB,EAAO,YAC3B,WAAa,OAAOA,GAErB,OADAJ,oBAAoBzL,EAAEgN,EAAQ,CAAEE,EAAGF,IAC5BA,G,cCLRvB,oBAAoBzL,EAAI,SAAS4L,EAASuB,GACzC,IAAI,IAAIzT,KAAOyT,EACX1B,oBAAoB2B,EAAED,EAAYzT,KAAS+R,oBAAoB2B,EAAExB,EAASlS,IAC5EiT,OAAOU,eAAezB,EAASlS,EAAK,CAAE4T,YAAY,EAAMC,IAAKJ,EAAWzT,M,cCJ3E+R,oBAAoB+B,EAAI,WACvB,GAA0B,kBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAO9T,MAAQ,IAAI+T,SAAS,cAAb,GACd,MAAOC,GACR,GAAsB,kBAAXC,OAAqB,OAAOA,QALjB,G,cCAxBnC,oBAAoBoC,IAAM,SAAShC,GASlC,OARAA,EAASc,OAAOmB,OAAOjC,GAClBA,EAAOkC,WAAUlC,EAAOkC,SAAW,IACxCpB,OAAOU,eAAexB,EAAQ,UAAW,CACxCyB,YAAY,EACZU,IAAK,WACJ,MAAM,IAAIC,MAAM,0FAA4FpC,EAAOC,OAG9GD,G,cCTRJ,oBAAoB2B,EAAI,SAASc,EAAKC,GAAQ,OAAOxB,OAAOyB,UAAU5J,eAAe6J,KAAKH,EAAKC,I,cCK/F,IAAIG,EAAkB,CACrB,IAAK,GAaN7C,oBAAoBU,EAAEO,EAAI,SAAS6B,GAAW,OAAoC,IAA7BD,EAAgBC,IAGrE,IAAIC,EAAuB,SAASC,EAA4BjI,GAC/D,IAKIkF,EAAU6C,EALVnC,EAAW5F,EAAK,GAChBkI,EAAclI,EAAK,GACnBmI,EAAUnI,EAAK,GAGI3J,EAAI,EAC3B,GAAGuP,EAASwC,MAAK,SAAS9C,GAAM,OAA+B,IAAxBwC,EAAgBxC,MAAe,CACrE,IAAIJ,KAAYgD,EACZjD,oBAAoB2B,EAAEsB,EAAahD,KACrCD,oBAAoBQ,EAAEP,GAAYgD,EAAYhD,IAGhD,GAAGiD,EAAS,IAAItN,EAASsN,EAAQlD,qBAGlC,IADGgD,GAA4BA,EAA2BjI,GACrD3J,EAAIuP,EAASrN,OAAQlC,IACzB0R,EAAUnC,EAASvP,GAChB4O,oBAAoB2B,EAAEkB,EAAiBC,IAAYD,EAAgBC,IACrED,EAAgBC,GAAS,KAE1BD,EAAgBC,GAAW,EAE5B,OAAO9C,oBAAoBU,EAAE9K,IAG1BwN,EAAqBC,KAAK,4BAA8BA,KAAK,6BAA+B,GAChGD,EAAmBE,QAAQP,EAAqBQ,KAAK,KAAM,IAC3DH,EAAmBvE,KAAOkE,EAAqBQ,KAAK,KAAMH,EAAmBvE,KAAK0E,KAAKH,I,GC/CvF,IAAII,oBAAsBxD,oBAAoBU,OAAE/L,EAAW,CAAC,MAAM,WAAa,OAAOqL,oBAAoB,SAC1GwD,oBAAsBxD,oBAAoBU,EAAE8C,sB","sources":["webpack://retro-picker/./src/javascript/Winwheel.js","webpack://retro-picker/./src/App.vue?aba7","webpack://retro-picker/./src/components/Games/GamesComponent.vue?7e7f","webpack://retro-picker/./src/components/Games/Wheel/WheelComponent.vue?1d6c","webpack://retro-picker/src/components/Games/Wheel/WheelComponent.vue","webpack://retro-picker/./src/components/Games/Wheel/WheelComponent.vue?aeca","webpack://retro-picker/./src/components/Games/Wheel/WheelComponent.vue","webpack://retro-picker/./src/components/Games/NameChooser.vue?e941","webpack://retro-picker/src/components/Games/NameChooser.vue","webpack://retro-picker/./src/components/Games/NameChooser.vue?1a45","webpack://retro-picker/./src/components/Games/NameChooser.vue","webpack://retro-picker/src/components/Games/GamesComponent.vue","webpack://retro-picker/./src/components/Games/GamesComponent.vue?f6d1","webpack://retro-picker/./src/components/Games/GamesComponent.vue","webpack://retro-picker/./src/components/NavbarComponent.vue?716c","webpack://retro-picker/src/components/NavbarComponent.vue","webpack://retro-picker/./src/components/NavbarComponent.vue?9907","webpack://retro-picker/./src/components/NavbarComponent.vue","webpack://retro-picker/src/App.vue","webpack://retro-picker/./src/App.vue?facb","webpack://retro-picker/./src/App.vue","webpack://retro-picker/./src/store/store.js","webpack://retro-picker/./src/router.js","webpack://retro-picker/./src/main.js","webpack://retro-picker/webpack/bootstrap","webpack://retro-picker/webpack/runtime/chunk loaded","webpack://retro-picker/webpack/runtime/compat get default export","webpack://retro-picker/webpack/runtime/define property getters","webpack://retro-picker/webpack/runtime/global","webpack://retro-picker/webpack/runtime/harmony module decorator","webpack://retro-picker/webpack/runtime/hasOwnProperty shorthand","webpack://retro-picker/webpack/runtime/jsonp chunk loading","webpack://retro-picker/webpack/startup"],"sourcesContent":["import { TweenMax } from 'gsap'\n\n/* eslint-disable */\nexport class Winwheel {\n\tconstructor(options, drawWheel) {\n\t\tvar defaultOptions = {\n\t\t\tcanvasId: 'canvas', // Id of the canvas which the wheel is to draw on to.\n\t\t\tcenterX: null, // X position of the center of the wheel. The default of these are null which means will be placed in center of the canvas.\n\t\t\tcenterY: null, // Y position of the wheel center. If left null at time of construct the center of the canvas is used.\n\t\t\touterRadius: null, // The radius of the outside of the wheel. If left null it will be set to the radius from the center of the canvas to its shortest side.\n\t\t\tinnerRadius: 0, // Normally 0. Allows the creation of rings / doughnuts if set to value > 0. Should not exceed outer radius.\n\t\t\tnumSegments: 1, // The number of segments. Need at least one to draw.\n\t\t\tdrawMode: 'code', // The draw mode. Possible values are 'code', 'image', 'segmentImage'. Default is code which means segments are drawn using canvas arc() function.\n\t\t\trotationAngle: 0, // The angle of rotation of the wheel - 0 is 12 o'clock position.\n\t\t\ttextFontFamily: 'sans-serif', // Segment text font, you should use web safe fonts.\n\t\t\ttextFontSize: 13, // Size of the segment text.\n\t\t\ttextFontWeight: 'bold', // Font weight.\n\t\t\ttextOrientation: 'horizontal', // Either horizontal, vertical, or curved.\n\t\t\ttextAlignment: 'center', // Either center, inner, or outer.\n\t\t\ttextDirection: 'normal', // Either normal or reversed. In normal mode for horizontal text in segment at 3 o'clock is correct way up, in reversed text at 9 o'clock segment is correct way up.\n\t\t\ttextMargin: null, // Margin between the inner or outer of the wheel (depends on textAlignment).\n\t\t\ttextFillStyle: 'black', // This is basically the text colour.\n\t\t\ttextStrokeStyle: null, // Basically the line colour for segment text, only looks good for large text so off by default.\n\t\t\ttextLineWidth: 1, // Width of the lines around the text. Even though this defaults to 1, a line is only drawn if textStrokeStyle specified.\n\t\t\tfillStyle: 'silver', // The segment background colour.\n\t\t\tstrokeStyle: null, // Segment line colour. Again segment lines only drawn if this is specified.\n\t\t\tlineWidth: 1, // Width of lines around segments.\n\t\t\tclearTheCanvas: true, // When set to true the canvas will be cleared before the wheel is drawn.\n\t\t\timageOverlay: false, // If set to true in image drawing mode the outline of the segments will be displayed over the image. Does nothing in code drawMode.\n\t\t\tdrawText: true, // By default the text of the segments is rendered in code drawMode and not in image drawMode.\n\t\t\tpointerAngle: 0, // Location of the pointer that indicates the prize when wheel has stopped. Default is 0 so the (corrected) 12 o'clock position.\n\t\t\twheelImage: null, // Must be set to image data in order to use image to draw the wheel - drawMode must also be 'image'.\n\t\t\timageDirection: 'N', // Used when drawMode is segmentImage. Default is north, can also be (E)ast, (S)outh, (W)est.\n\t\t}\n\n\t\t// -----------------------------------------\n\t\t// Loop through the default options and create properties of this class set to the value for the option passed in\n\t\t// or if not value for the option was passed in then to the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the id of the canvas is set, try to get the canvas as we need it for drawing.\n\t\tif (this.canvasId) {\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\t// If the centerX and centerY have not been specified in the options then default to center of the canvas\n\t\t\t\t// and make the outerRadius half of the canvas width - this means the wheel will fill the canvas.\n\t\t\t\tif (this.centerX == null) {\n\t\t\t\t\tthis.centerX = this.canvas.width / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.centerY == null) {\n\t\t\t\t\tthis.centerY = this.canvas.height / 2\n\t\t\t\t}\n\n\t\t\t\tif (this.outerRadius == null) {\n\t\t\t\t\t// Need to set to half the width of the shortest dimension of the canvas as the canvas may not be square.\n\t\t\t\t\t// Minus the line segment line width otherwise the lines around the segments on the top,left,bottom,right\n\t\t\t\t\t// side are chopped by the edge of the canvas.\n\t\t\t\t\tif (this.canvas.width < this.canvas.height) {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.width / 2 - this.lineWidth\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.outerRadius = this.canvas.height / 2 - this.lineWidth\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Also get a 2D context to the canvas as we need this to draw with.\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t} else {\n\t\t\t\tthis.canvas = null\n\t\t\t\tthis.ctx = null\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cavnas = null\n\t\t\tthis.ctx = null\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Add array of segments to the wheel, then populate with segments if number of segments is specified for this object.\n\t\tthis.segments = new Array(null)\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// If options for the segments have been specified then create a segment sending these options so\n\t\t\t// the specified values are used instead of the defaults.\n\t\t\tif (options != null && options['segments'] && typeof options['segments'][x - 1] !== 'undefined') {\n\t\t\t\tthis.segments[x] = new Segment(options['segments'][x - 1])\n\t\t\t} else {\n\t\t\t\tthis.segments[x] = new Segment()\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// Call function to update the segment sizes setting the starting and ending angles.\n\t\tthis.updateSegmentSizes()\n\n\t\t// If the text margin is null then set to same as font size as we want some by default.\n\t\tif (this.textMargin === null) {\n\t\t\tthis.textMargin = this.textFontSize / 1.7\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If the animation options have been passed in then create animation object as a property of this class\n\t\t// and pass the options to it so the animation is set. Otherwise create default animation object.\n\t\tif (options != null && options['animation'] && typeof options['animation'] !== 'undefined') {\n\t\t\tthis.animation = new Animation(options['animation'])\n\t\t} else {\n\t\t\tthis.animation = new Animation()\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// If some pin options then create create a pin object and then pass them in.\n\t\tif (options != null && options['pins'] && typeof options['pins'] !== 'undefined') {\n\t\t\tthis.pins = new Pin(options['pins'])\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// On that note, if the drawMode is image change some defaults provided a value has not been specified.\n\t\tif (this.drawMode == 'image' || this.drawMode == 'segmentImage') {\n\t\t\t// Remove grey fillStyle.\n\t\t\tif (typeof options['fillStyle'] === 'undefined') {\n\t\t\t\tthis.fillStyle = null\n\t\t\t}\n\n\t\t\t// Set strokeStyle to red.\n\t\t\tif (typeof options['strokeStyle'] === 'undefined') {\n\t\t\t\tthis.strokeStyle = 'red'\n\t\t\t}\n\n\t\t\t// Set drawText to false as we will assume any text is part of the image.\n\t\t\tif (typeof options['drawText'] === 'undefined') {\n\t\t\t\tthis.drawText = false\n\t\t\t}\n\n\t\t\t// Also set the lineWidth to 1 so that segment overlay will look correct.\n\t\t\tif (typeof options['lineWidth'] === 'undefined') {\n\t\t\t\tthis.lineWidth = 1\n\t\t\t}\n\n\t\t\t// Set drawWheel to false as normally the image needs to be loaded first.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = false\n\t\t\t}\n\t\t} else {\n\t\t\t// When in code drawMode the default is the wheel will draw.\n\t\t\tif (typeof drawWheel === 'undefined') {\n\t\t\t\tdrawWheel = true\n\t\t\t}\n\t\t}\n\n\t\t// Create pointer guide.\n\t\tif (options != null && options['pointerGuide'] && typeof options['pointerGuide'] !== 'undefined') {\n\t\t\tthis.pointerGuide = new PointerGuide(options['pointerGuide'])\n\t\t} else {\n\t\t\tthis.pointerGuide = new PointerGuide()\n\t\t}\n\n\t\t// Finally if drawWheel is true then call function to render the wheel, segment text, overlay etc.\n\t\tif (drawWheel == true) {\n\t\t\tthis.draw(this.clearTheCanvas)\n\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t// If segment image then loop though all the segments and load the images for them setting a callback\n\t\t\t// which will call the draw function of the wheel once all the images have been loaded.\n\t\t\twinwheelToDrawDuringAnimation = this\n\t\t\twinhweelAlreadyDrawn = false\n\n\t\t\tfor (var y = 1; y <= this.numSegments; y++) {\n\t\t\t\tif (this.segments[y].image !== null) {\n\t\t\t\t\tthis.segments[y].imgData = new Image()\n\t\t\t\t\tthis.segments[y].imgData.onload = winwheelLoadedImage\n\t\t\t\t\tthis.segments[y].imgData.src = this.segments[y].image\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function sorts out the segment sizes. Some segments may have set sizes, for the others what is left out of\n\t// 360 degrees is shared evenly. What this function actually does is set the start and end angle of the arcs.\n\t// ====================================================================================================================\n\tupdateSegmentSizes() {\n\t\t// If this object actually contains some segments\n\t\tif (this.segments) {\n\t\t\t// First add up the arc used for the segments where the size has been set.\n\t\t\tvar arcUsed = 0\n\t\t\tvar numSet = 0\n\n\t\t\t// Remember, to make it easy to access segments, the position of the segments in the array starts from 1 (not 0).\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\tif (this.segments[x].size !== null) {\n\t\t\t\t\tarcUsed += this.segments[x].size\n\t\t\t\t\tnumSet++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar arcLeft = 360 - arcUsed\n\n\t\t\t// Create variable to hold how much each segment with non-set size will get in terms of degrees.\n\t\t\tvar degreesEach = 0\n\n\t\t\tif (arcLeft > 0) {\n\t\t\t\tdegreesEach = arcLeft / (this.numSegments - numSet)\n\t\t\t}\n\n\t\t\t// ------------------------------------------\n\t\t\t// Now loop though and set the start and end angle of each segment.\n\t\t\tvar currentDegree = 0\n\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Set start angle.\n\t\t\t\tthis.segments[x].startAngle = currentDegree\n\n\t\t\t\t// If the size is set then add this to the current degree to get the end, else add the degreesEach to it.\n\t\t\t\tif (this.segments[x].size) {\n\t\t\t\t\tcurrentDegree += this.segments[x].size\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDegree += degreesEach\n\t\t\t\t}\n\n\t\t\t\t// Set end angle.\n\t\t\t\tthis.segments[x].endAngle = currentDegree\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function clears the canvas. Will wipe anything else which happens to be drawn on it.\n\t// ====================================================================================================================\n\tclearCanvas() {\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws / re-draws the wheel on the canvas therefore rendering any changes.\n\t// ====================================================================================================================\n\tdraw(clearTheCanvas) {\n\t\t// If have the canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Clear the canvas, unless told not to.\n\t\t\tif (typeof clearTheCanvas !== 'undefined') {\n\t\t\t\tif (clearTheCanvas == true) {\n\t\t\t\t\tthis.clearCanvas()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.clearCanvas()\n\t\t\t}\n\n\t\t\t// Call functions to draw the segments and then segment text.\n\t\t\tif (this.drawMode == 'image') {\n\t\t\t\t// Draw the wheel by loading and drawing an image such as a png on the canvas.\n\t\t\t\tthis.drawWheelImage()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else if (this.drawMode == 'segmentImage') {\n\t\t\t\t// Draw the wheel by rendering the image for each segment.\n\t\t\t\tthis.drawSegmentImages()\n\n\t\t\t\t// If we are to draw the text, do so before the overlay is drawn\n\t\t\t\t// as this allows the overlay to be used to create some interesting effects.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\n\t\t\t\t// If image overlay is true then call function to draw the segments over the top of the image.\n\t\t\t\t// This is useful during development to check alignment between where the code thinks the segments are and where they appear on the image.\n\t\t\t\tif (this.imageOverlay == true) {\n\t\t\t\t\tthis.drawSegments()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The default operation is to draw the segments using code via the canvas arc() method.\n\t\t\t\tthis.drawSegments()\n\n\t\t\t\t// The text is drawn on top.\n\t\t\t\tif (this.drawText == true) {\n\t\t\t\t\tthis.drawSegmentText()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this class has pins.\n\t\t\tif (typeof this.pins !== 'undefined') {\n\t\t\t\t// If they are to be visible then draw them.\n\t\t\t\tif (this.pins.visible == true) this.drawPins()\n\t\t\t}\n\n\t\t\t// If pointer guide is display property is set to true then call function to draw the pointer guide.\n\t\t\tif (this.pointerGuide.display == true) {\n\t\t\t\tthis.drawPointerGuide()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws the pins around the outside of the wheel.\n\t// ====================================================================================================================\n\tdrawPins() {\n\t\tif (this.pins && this.pins.number) {\n\t\t\t// Work out the angle to draw each pin a which is simply 360 / the number of pins as they space evenly around.\n\t\t\t//++ There is a slight oddity with the pins in that there is a pin at 0 and also one at 360 and these will be drawn\n\t\t\t//++ directly over the top of each other. Also pins are 0 indexed which could possibly cause some confusion\n\t\t\t//++ with the getCurrentPin function - for now this is just used for audio so probably not a problem.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\n\t\t\tfor (var i = 1; i <= this.pins.number; i++) {\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Set the stroke style and line width.\n\t\t\t\tthis.ctx.strokeStyle = this.pins.strokeStyle\n\t\t\t\tthis.ctx.lineWidth = this.pins.lineWidth\n\t\t\t\tthis.ctx.fillStyle = this.pins.fillStyle\n\n\t\t\t\t// Move to the center.\n\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t// Rotate to to the pin location which is i * the pinSpacing.\n\t\t\t\tthis.ctx.rotate(this.degToRad(i * pinSpacing + this.rotationAngle))\n\n\t\t\t\t// Move back out.\n\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t// Create a path for the pin circle.\n\t\t\t\tthis.ctx.beginPath()\n\t\t\t\t// x, y, radius, startAngle, endAngle.\n\t\t\t\tthis.ctx.arc(\n\t\t\t\t\tthis.centerX,\n\t\t\t\t\tthis.centerY - this.outerRadius + this.pins.outerRadius + this.pins.margin,\n\t\t\t\t\tthis.pins.outerRadius,\n\t\t\t\t\t0,\n\t\t\t\t\t2 * Math.PI\n\t\t\t\t)\n\n\t\t\t\tif (this.pins.fillStyle) this.ctx.fill()\n\n\t\t\t\tif (this.pins.strokeStyle) this.ctx.stroke()\n\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Draws a line from the center of the wheel to the outside at the angle where the code thinks the pointer is.\n\t// ====================================================================================================================\n\tdrawPointerGuide() {\n\t\t// If have canvas context.\n\t\tif (this.ctx) {\n\t\t\tthis.ctx.save()\n\n\t\t\t// Rotate the canvas to the line goes towards the location of the pointer.\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.pointerAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t// Set line colour and width.\n\t\t\tthis.ctx.strokeStyle = this.pointerGuide.strokeStyle\n\t\t\tthis.ctx.lineWidth = this.pointerGuide.lineWidth\n\n\t\t\t// Draw from the center of the wheel outwards past the wheel outer radius.\n\t\t\tthis.ctx.beginPath()\n\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\tthis.ctx.lineTo(this.centerX, -(this.outerRadius / 4))\n\n\t\t\tthis.ctx.stroke()\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes an image such as PNG and draws it on the canvas making its center at the centerX and center for the wheel.\n\t// ====================================================================================================================\n\tdrawWheelImage() {\n\t\t// Double check the wheelImage property of this class is not null. This does not actually detect that an image\n\t\t// source was set and actually loaded so might get error if this is not the case. This is why the initial call\n\t\t// to draw() should be done from a wheelImage.onload callback as detailed in example documentation.\n\t\tif (this.wheelImage != null) {\n\t\t\t// Work out the correct X and Y to draw the image at. We need to get the center point of the image\n\t\t\t// aligned over the center point of the wheel, we can't just place it at 0, 0.\n\t\t\tvar imageLeft = this.centerX - this.wheelImage.height / 2\n\t\t\tvar imageTop = this.centerY - this.wheelImage.width / 2\n\n\t\t\t// Rotate and then draw the wheel.\n\t\t\t// We must rotate by the rotationAngle before drawing to ensure that image wheels will spin.\n\t\t\tthis.ctx.save()\n\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle))\n\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\tthis.ctx.drawImage(this.wheelImage, imageLeft, imageTop)\n\n\t\t\tthis.ctx.restore()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the canvas by rendering the image for each segment.\n\t// ====================================================================================================================\n\tdrawSegmentImages() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\t// Check image has loaded so a property such as height has a value.\n\t\t\t\t\tif (seg.imgData.height) {\n\t\t\t\t\t\t// Work out the correct X and Y to draw the image at which depends on the direction of the image.\n\t\t\t\t\t\t// Images can be created in 4 directions. North, South, East, West.\n\t\t\t\t\t\t// North: Outside at top, inside at bottom. Sits evenly over the 0 degrees angle.\n\t\t\t\t\t\t// South: Outside at bottom, inside at top. Sits evenly over the 180 degrees angle.\n\t\t\t\t\t\t// East: Outside at right, inside at left. Sits evenly over the 90 degrees angle.\n\t\t\t\t\t\t// West: Outside at left, inside at right. Sits evenly over the 270 degrees angle.\n\t\t\t\t\t\tvar imageLeft = 0\n\t\t\t\t\t\tvar imageTop = 0\n\t\t\t\t\t\tvar imageAngle = 0\n\t\t\t\t\t\tvar imageDirection = ''\n\n\t\t\t\t\t\tif (seg.imageDirection !== null) imageDirection = seg.imageDirection\n\t\t\t\t\t\telse imageDirection = this.imageDirection\n\n\t\t\t\t\t\tif (imageDirection == 'S') {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 180 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image starts at the centerY.\n\t\t\t\t\t\t\timageTop = this.centerY\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// Here we add 180 to the angle to the segment is poistioned correctly.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 180 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'E') {\n\t\t\t\t\t\t\t// Left set so image starts and the center point.\n\t\t\t\t\t\t\timageLeft = this.centerX\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 90 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 270 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 270 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} else if (imageDirection == 'W') {\n\t\t\t\t\t\t\t// Left is the centerX minus the width of the image.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width\n\n\t\t\t\t\t\t\t// Top is so that it sits half/half over the 270 degree point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height / 2\n\n\t\t\t\t\t\t\t// Again get the angle in the center of the segment and add it to the rotation angle.\n\t\t\t\t\t\t\t// this time we need to add 90 to that to the segment is rendered the correct place.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + 90 + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t} // North is the default.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Left set so image sits half/half over the 0 degrees point.\n\t\t\t\t\t\t\timageLeft = this.centerX - seg.imgData.width / 2\n\n\t\t\t\t\t\t\t// Top so image is its height out (above) the center point.\n\t\t\t\t\t\t\timageTop = this.centerY - seg.imgData.height\n\n\t\t\t\t\t\t\t// Angle to draw the image is its starting angle + half its size.\n\t\t\t\t\t\t\t// this sits it half/half over the center angle of the segment.\n\t\t\t\t\t\t\timageAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// --------------------------------------------------\n\t\t\t\t\t\t// Rotate to the position of the segment and then draw the image.\n\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\n\t\t\t\t\t\t// So math here is the rotation angle of the wheel plus half way between the start and end angle of the segment.\n\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(this.rotationAngle + imageAngle))\n\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t// Draw the image.\n\t\t\t\t\t\tthis.ctx.drawImage(seg.imgData, imageLeft, imageTop)\n\n\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Segment ' + x + ' imgData is not loaded')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function draws the wheel on the page by rendering the segments on the canvas.\n\t// ====================================================================================================================\n\tdrawSegments() {\n\t\t// Again check have context in case this function was called directly and not via draw function.\n\t\tif (this.ctx) {\n\t\t\t// Draw the segments if there is at least one in the segments array.\n\t\t\tif (this.segments) {\n\t\t\t\t// Loop though and output all segments - position 0 of the array is not used, so start loop from index 1\n\t\t\t\t// this is to avoid confusion when talking about the first segment.\n\t\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t\tvar fillStyle\n\t\t\t\t\tvar lineWidth\n\t\t\t\t\tvar strokeStyle\n\n\t\t\t\t\t// Set the variables that defined in the segment, or use the default options.\n\t\t\t\t\tif (seg.fillStyle !== null) fillStyle = seg.fillStyle\n\t\t\t\t\telse fillStyle = this.fillStyle\n\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\n\t\t\t\t\tif (seg.lineWidth !== null) lineWidth = seg.lineWidth\n\t\t\t\t\telse lineWidth = this.lineWidth\n\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\tif (seg.strokeStyle !== null) strokeStyle = seg.strokeStyle\n\t\t\t\t\telse strokeStyle = this.strokeStyle\n\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\n\t\t\t\t\t// Check there is a strokeStyle or fillStyle, if either the the segment is invisible so should not\n\t\t\t\t\t// try to draw it otherwise a path is began but not ended.\n\t\t\t\t\tif (strokeStyle || fillStyle) {\n\t\t\t\t\t\t// ----------------------------------\n\t\t\t\t\t\t// Begin a path as the segment consists of an arc and 2 lines.\n\t\t\t\t\t\tthis.ctx.beginPath()\n\n\t\t\t\t\t\t// If don't have an inner radius then move to the center of the wheel as we want a line out from the center\n\t\t\t\t\t\t// to the start of the arc for the outside of the wheel when we arc. Canvas will draw the connecting line for us.\n\t\t\t\t\t\tif (!this.innerRadius) {\n\t\t\t\t\t\t\tthis.ctx.moveTo(this.centerX, this.centerY)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//++ do need to draw the starting line in the correct x + y based on the start angle\n\t\t\t\t\t\t\t//++ otherwise as seen when the wheel does not use up 360 the starting segment is missing the stroked side,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw the outer arc of the segment clockwise in direction -->\n\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\tthis.outerRadius,\n\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (this.innerRadius) {\n\t\t\t\t\t\t\t// Draw another arc, this time anticlockwise <-- at the innerRadius between the end angle and the start angle.\n\t\t\t\t\t\t\t// Canvas will draw a connecting line from the end of the outer arc to the beginning of the inner arc completing the shape.\n\n\t\t\t\t\t\t\t//++ Think the reason the lines are thinner for 2 of the segments is because the thing auto chops part of it\n\t\t\t\t\t\t\t//++ when doing the next one. Again think that actually drawing the lines will help.\n\n\t\t\t\t\t\t\tthis.ctx.arc(\n\t\t\t\t\t\t\t\tthis.centerX,\n\t\t\t\t\t\t\t\tthis.centerY,\n\t\t\t\t\t\t\t\tthis.innerRadius,\n\t\t\t\t\t\t\t\tthis.degToRad(seg.endAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\tthis.degToRad(seg.startAngle + this.rotationAngle - 90),\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If no inner radius then we draw a line back to the center of the wheel.\n\t\t\t\t\t\t\tthis.ctx.lineTo(this.centerX, this.centerY)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fill and stroke the segment. Only do either if a style was specified, if the style is null then\n\t\t\t\t\t\t// we assume the developer did not want that particular thing.\n\t\t\t\t\t\t// For example no stroke style so no lines to be drawn.\n\t\t\t\t\t\tif (fillStyle) this.ctx.fill()\n\n\t\t\t\t\t\tif (strokeStyle) this.ctx.stroke()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This draws the text on the segments using the specified text options.\n\t// ====================================================================================================================\n\tdrawSegmentText() {\n\t\t// Again only draw the text if have a canvas context.\n\t\tif (this.ctx) {\n\t\t\t// Declare variables to hold the values. These are populated either with the value for the specific segment,\n\t\t\t// or if not specified then the global default value.\n\t\t\tvar fontFamily\n\t\t\tvar fontSize\n\t\t\tvar fontWeight\n\t\t\tvar orientation\n\t\t\tvar alignment\n\t\t\tvar direction\n\t\t\tvar margin\n\t\t\tvar fillStyle\n\t\t\tvar strokeStyle\n\t\t\tvar lineWidth\n\t\t\tvar fontSetting\n\n\t\t\t// Loop though all the segments.\n\t\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t\t// Save the context so it is certain that each segment text option will not affect the other.\n\t\t\t\tthis.ctx.save()\n\n\t\t\t\t// Get the segment object as we need it to read options from.\n\t\t\t\tvar seg = this.segments[x]\n\n\t\t\t\t// Check is text as no point trying to draw if there is no text to render.\n\t\t\t\tif (seg.text) {\n\t\t\t\t\t// Set values to those for the specific segment or use global default if null.\n\t\t\t\t\tif (seg.textFontFamily !== null) fontFamily = seg.textFontFamily\n\t\t\t\t\telse fontFamily = this.textFontFamily\n\t\t\t\t\tif (seg.textFontSize !== null) fontSize = seg.textFontSize\n\t\t\t\t\telse fontSize = this.textFontSize\n\t\t\t\t\tif (seg.textFontWeight !== null) fontWeight = seg.textFontWeight\n\t\t\t\t\telse fontWeight = this.textFontWeight\n\t\t\t\t\tif (seg.textOrientation !== null) orientation = seg.textOrientation\n\t\t\t\t\telse orientation = this.textOrientation\n\t\t\t\t\tif (seg.textAlignment !== null) alignment = seg.textAlignment\n\t\t\t\t\telse alignment = this.textAlignment\n\t\t\t\t\tif (seg.textDirection !== null) direction = seg.textDirection\n\t\t\t\t\telse direction = this.textDirection\n\t\t\t\t\tif (seg.textMargin !== null) margin = seg.textMargin\n\t\t\t\t\telse margin = this.textMargin\n\t\t\t\t\tif (seg.textFillStyle !== null) fillStyle = seg.textFillStyle\n\t\t\t\t\telse fillStyle = this.textFillStyle\n\t\t\t\t\tif (seg.textStrokeStyle !== null) strokeStyle = seg.textStrokeStyle\n\t\t\t\t\telse strokeStyle = this.textStrokeStyle\n\t\t\t\t\tif (seg.textLineWidth !== null) lineWidth = seg.textLineWidth\n\t\t\t\t\telse lineWidth = this.textLineWidth\n\n\t\t\t\t\t// ------------------------------\n\t\t\t\t\t// We need to put the font bits together in to one string.\n\t\t\t\t\tfontSetting = ''\n\n\t\t\t\t\tif (fontWeight != null) fontSetting += fontWeight + ' '\n\n\t\t\t\t\tif (fontSize != null) fontSetting += fontSize + 'px ' // Fonts on canvas are always a px value.\n\n\t\t\t\t\tif (fontFamily != null) fontSetting += fontFamily\n\n\t\t\t\t\t// Now set the canvas context to the decided values.\n\t\t\t\t\tthis.ctx.font = fontSetting\n\t\t\t\t\tthis.ctx.fillStyle = fillStyle\n\t\t\t\t\tthis.ctx.strokeStyle = strokeStyle\n\t\t\t\t\tthis.ctx.lineWidth = lineWidth\n\n\t\t\t\t\t// Split the text in to multiple lines on the \\n character.\n\t\t\t\t\tvar lines = seg.text.split('\\n')\n\n\t\t\t\t\t// Figure out the starting offset for the lines as when there are multiple lines need to center the text\n\t\t\t\t\t// vertically in the segment (when thinking of normal horozontal text).\n\t\t\t\t\tvar lineOffset = 0 - fontSize * (lines.length / 2) + fontSize / 2\n\n\t\t\t\t\t// The offset works great for horozontal and vertial text, also centered curved. But when the text is curved\n\t\t\t\t\t// and the alignment is outer then the multiline text should not have some text outside the wheel. Same if inner curved.\n\t\t\t\t\tif (orientation == 'curved' && (alignment == 'inner' || alignment == 'outer')) {\n\t\t\t\t\t\tlineOffset = 0\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\t\t\t// ---------------------------------\n\t\t\t\t\t\t// If direction is reversed then do things differently than if normal (which is the default - see further down)\n\t\t\t\t\t\tif (direction == 'reversed') {\n\t\t\t\t\t\t\t// When drawing reversed or 'upside down' we need to do some trickery on our part.\n\t\t\t\t\t\t\t// The canvas text rendering function still draws the text left to right and the correct way up,\n\t\t\t\t\t\t\t// so we need to overcome this with rotating the opposite side of the wheel the correct way up then pulling the text\n\t\t\t\t\t\t\t// through the center point to the correct segment it is supposed to be on.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle to rotate the wheel, this is in the center of the segment but on the opposite side of the wheel which is why do -180.\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90 - 180\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed state the margin is subtracted from the innerX.\n\t\t\t\t\t\t\t\t\t// When inner the inner radius also comes in to play.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.innerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed state the position is the center minus the radius + the margin for outer aligned text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX - this.outerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In reversed state the everything in minused.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX -\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// See normal code further down for comments on how it works, this is similar by plus/minus is reversed.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// In reversed mode this are reversed.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY + this.outerRadius - margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY + this.innerRadius + margin\n\n\t\t\t\t\t\t\t\t// I have found that the text looks best when a fraction of the font size is shaved off.\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// In reversed mode outer means text in 6 o'clock segment sits at bottom of the wheel and we draw up.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// In reversed mode inner text is drawn from top of segment at 6 o'clock position to bottom of the wheel.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// Again for reversed this is the opposite of before.\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY +\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment +\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc,\n\t\t\t\t\t\t\t\t// so we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius -= fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centered.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// And as with other 'reverse' text direction functions we need to subtract 180 degrees from the angle\n\t\t\t\t\t\t\t\t// because when it comes to draw the characters in the loop below we add the radius instead of subtract it.\n\t\t\t\t\t\t\t\tdrawAngle -= 180\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// In reversed direction mode we loop through the characters in the text backwards in order for them to appear on screen correctly\n\t\t\t\t\t\t\t\tfor (c = lines[i].length; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly below the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\t// Note in the reversed mode we add the radius to the this.centerY instead of subtract.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY + radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Normal direction so do things normally.\n\t\t\t\t\t\t\t// Check text orientation, of horizontal then reasonably straight forward, if vertical then a bit more work to do.\n\t\t\t\t\t\t\tif (orientation == 'horizontal') {\n\t\t\t\t\t\t\t\t// Based on the text alignment, set the correct value in the context.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textAlign = 'left'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textAlign = 'right'\n\t\t\t\t\t\t\t\telse this.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\t// Set this too.\n\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// Work out the angle around the wheel to draw the text at, which is simply in the middle of the segment the text is for.\n\t\t\t\t\t\t\t\t// The rotation angle is added in to correct the annoyance with the canvas arc drawing functions which put the 0 degrees at the 3 oclock\n\t\t\t\t\t\t\t\tvar textAngle = this.degToRad(\n\t\t\t\t\t\t\t\t\tseg.endAngle - (seg.endAngle - seg.startAngle) / 2 + this.rotationAngle - 90\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t// We need to rotate in order to draw the text because it is output horizontally, so to\n\t\t\t\t\t\t\t\t// place correctly around the wheel for all but a segment at 3 o'clock we need to rotate.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(textAngle)\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// --------------------------\n\t\t\t\t\t\t\t\t// Draw the text based on its alignment adding margin if inner or outer.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Inner means that the text is aligned with the inner of the wheel. If looking at a segment in in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would look like the text is left aligned within the segment.\n\n\t\t\t\t\t\t\t\t\t// Because the segments are smaller towards the inner of the wheel, in order for the text to fit is is a good idea that\n\t\t\t\t\t\t\t\t\t// a margin is added which pushes the text towards the outer a bit.\n\n\t\t\t\t\t\t\t\t\t// The inner radius also needs to be taken in to account as when inner aligned.\n\n\t\t\t\t\t\t\t\t\t// If fillstyle is set the draw the text filled in.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If stroke style is set draw the text outline.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.innerRadius + margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer means the text is aligned with the outside of the wheel, so if looking at a segment in the 3 o'clock position\n\t\t\t\t\t\t\t\t\t// it would appear the text is right aligned. To position we add the radius of the wheel in to the equation\n\t\t\t\t\t\t\t\t\t// and subtract the margin this time, rather than add it.\n\n\t\t\t\t\t\t\t\t\t// I don't understand why, but in order of the text to render correctly with stroke and fill, the stroke needs to\n\t\t\t\t\t\t\t\t\t// come first when drawing outer, rather than second when doing inner.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX + this.outerRadius - margin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// In this case the text is to drawn centred in the segment.\n\t\t\t\t\t\t\t\t\t// Typically no margin is required, however even though centred the text can look closer to the inner of the wheel\n\t\t\t\t\t\t\t\t\t// due to the way the segments narrow in (is optical effect), so if a margin is specified it is placed on the inner\n\t\t\t\t\t\t\t\t\t// side so the text is pushed towards the outer.\n\n\t\t\t\t\t\t\t\t\t// If stoke style the stroke the text.\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t// If fillstyle the fill the text.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(\n\t\t\t\t\t\t\t\t\t\t\tlines[i],\n\t\t\t\t\t\t\t\t\t\t\tthis.centerX +\n\t\t\t\t\t\t\t\t\t\t\t\tthis.innerRadius +\n\t\t\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 +\n\t\t\t\t\t\t\t\t\t\t\t\tmargin,\n\t\t\t\t\t\t\t\t\t\t\tthis.centerY + lineOffset\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Restore the context so that wheel is returned to original position.\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'vertical') {\n\t\t\t\t\t\t\t\t// If vertical then we need to do this ourselves because as far as I am aware there is no option built in to html canvas\n\t\t\t\t\t\t\t\t// which causes the text to draw downwards or upwards one character after another.\n\n\t\t\t\t\t\t\t\t// In this case the textAlign is always center, but the baseline is either top or bottom\n\t\t\t\t\t\t\t\t// depending on if inner or outer alignment has been specified.\n\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\n\t\t\t\t\t\t\t\tif (alignment == 'inner') this.ctx.textBaseline = 'bottom'\n\t\t\t\t\t\t\t\telse if (alignment == 'outer') this.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\telse this.ctx.textBaseline = 'middle'\n\n\t\t\t\t\t\t\t\t// The angle to draw the text at is halfway between the end and the starting angle of the segment.\n\t\t\t\t\t\t\t\tvar textAngle = seg.endAngle - (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t// Ensure the rotation angle of the wheel is added in, otherwise the test placement won't match\n\t\t\t\t\t\t\t\t// the segments they are supposed to be for.\n\t\t\t\t\t\t\t\ttextAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// Rotate so can begin to place the text.\n\t\t\t\t\t\t\t\tthis.ctx.save()\n\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(textAngle))\n\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t// Work out the position to start drawing in based on the alignment.\n\t\t\t\t\t\t\t\t// If outer then when considering a segment at the 12 o'clock position want to start drawing down from the top of the wheel.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') var yPos = this.centerY - this.outerRadius + margin\n\t\t\t\t\t\t\t\telse if (alignment == 'inner') var yPos = this.centerY - this.innerRadius - margin\n\n\t\t\t\t\t\t\t\t// We need to know how much to move the y axis each time.\n\t\t\t\t\t\t\t\t// This is not quite simply the font size as that puts a larger gap in between the letters\n\t\t\t\t\t\t\t\t// than expected, especially with monospace fonts. I found that shaving a little off makes it look \"right\".\n\t\t\t\t\t\t\t\tvar yInc = fontSize - fontSize / 9\n\n\t\t\t\t\t\t\t\t// Loop though and output the characters.\n\t\t\t\t\t\t\t\tif (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// For this alignment we draw down from the top of a segment at the 12 o'clock position to simply\n\t\t\t\t\t\t\t\t\t// loop though the characters in order.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// Here we draw from the inner of the wheel up, but in order for the letters in the text text to\n\t\t\t\t\t\t\t\t\t// remain in the correct order when reading, we actually need to loop though the text characters backwards.\n\t\t\t\t\t\t\t\t\tfor (var c = lines[i].length - 1; c >= 0; c--) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos -= yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// This is the most complex of the three as we need to draw the text top down centred between the inner and outer of the wheel.\n\t\t\t\t\t\t\t\t\t// So logically we have to put the middle character of the text in the center then put the others each side of it.\n\t\t\t\t\t\t\t\t\t// In reality that is a really bad way to do it, we can achieve the same if not better positioning using a\n\t\t\t\t\t\t\t\t\t// variation on the method used for the rendering of outer aligned text once we have figured out the height of the text.\n\n\t\t\t\t\t\t\t\t\t// If there is more than one character in the text then an adjustment to the position needs to be done.\n\t\t\t\t\t\t\t\t\t// What we are aiming for is to position the center of the text at the center point between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tvar centerAdjustment = 0\n\n\t\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment = (yInc * (lines[i].length - 1)) / 2\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Now work out where to start rendering the string. This is half way between the inner and outer of the wheel, with the\n\t\t\t\t\t\t\t\t\t// centerAdjustment included to correctly position texts with more than one character over the center.\n\t\t\t\t\t\t\t\t\t// If there is a margin it is used to push the text away from the center of the wheel.\n\t\t\t\t\t\t\t\t\tvar yPos =\n\t\t\t\t\t\t\t\t\t\tthis.centerY -\n\t\t\t\t\t\t\t\t\t\tthis.innerRadius -\n\t\t\t\t\t\t\t\t\t\t(this.outerRadius - this.innerRadius) / 2 -\n\t\t\t\t\t\t\t\t\t\tcenterAdjustment -\n\t\t\t\t\t\t\t\t\t\tmargin\n\n\t\t\t\t\t\t\t\t\t// Now loop and draw just like outer text rendering.\n\t\t\t\t\t\t\t\t\tfor (var c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t\tif (fillStyle) this.ctx.fillText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tif (strokeStyle) this.ctx.strokeText(character, this.centerX + lineOffset, yPos)\n\n\t\t\t\t\t\t\t\t\t\tyPos += yInc\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t} else if (orientation == 'curved') {\n\t\t\t\t\t\t\t\t// There is no built in canvas function to draw text around an arc, so\n\t\t\t\t\t\t\t\t// we need to do this ourselves.\n\t\t\t\t\t\t\t\tvar radius = 0\n\n\t\t\t\t\t\t\t\t// Set the alignment of the text - inner, outer, or center by calculating\n\t\t\t\t\t\t\t\t// how far out from the center point of the wheel the text is drawn.\n\t\t\t\t\t\t\t\tif (alignment == 'inner') {\n\t\t\t\t\t\t\t\t\t// When alignment is inner the radius is the innerRadius plus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'bottom'\n\n\t\t\t\t\t\t\t\t\t// We need to adjust the radius in this case to take in to multiline text.\n\t\t\t\t\t\t\t\t\t// In this case the radius needs to be further out, not at the inner radius.\n\t\t\t\t\t\t\t\t\tradius += fontSize * (lines.length - 1)\n\t\t\t\t\t\t\t\t} else if (alignment == 'outer') {\n\t\t\t\t\t\t\t\t\t// Outer it is the outerRadius minus any margin.\n\t\t\t\t\t\t\t\t\tradius = this.outerRadius - margin\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'top'\n\t\t\t\t\t\t\t\t} else if (alignment == 'center') {\n\t\t\t\t\t\t\t\t\t// When center we want the text halfway between the inner and outer radius.\n\t\t\t\t\t\t\t\t\tradius = this.innerRadius + margin + (this.outerRadius - this.innerRadius) / 2\n\t\t\t\t\t\t\t\t\tthis.ctx.textBaseline = 'middle'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the angle to increment by when looping though and outputting the characters in the text\n\t\t\t\t\t\t\t\t// as we do this by rotating the wheel small amounts adding each character.\n\t\t\t\t\t\t\t\tvar anglePerChar = 0\n\t\t\t\t\t\t\t\tvar drawAngle = 0\n\n\t\t\t\t\t\t\t\t// If more than one character in the text then...\n\t\t\t\t\t\t\t\tif (lines[i].length > 1) {\n\t\t\t\t\t\t\t\t\t// Text is drawn from the left.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'left'\n\n\t\t\t\t\t\t\t\t\t// Work out how much angle the text rendering loop below needs to rotate by for each character to render them next to each other.\n\t\t\t\t\t\t\t\t\t// I have discovered that 4 * the font size / 10 at 100px radius is the correct spacing for between the characters\n\t\t\t\t\t\t\t\t\t// using a monospace font, non monospace may look a little odd as in there will appear to be extra spaces between chars.\n\t\t\t\t\t\t\t\t\tanglePerChar = 4 * (fontSize / 10)\n\n\t\t\t\t\t\t\t\t\t// Work out what percentage the radius the text will be drawn at is of 100px.\n\t\t\t\t\t\t\t\t\tradiusPercent = 100 / radius\n\n\t\t\t\t\t\t\t\t\t// Then use this to scale up or down the anglePerChar value.\n\t\t\t\t\t\t\t\t\t// When the radius is less than 100px we need more angle between the letters, when radius is greater (so the text is further\n\t\t\t\t\t\t\t\t\t// away from the center of the wheel) the angle needs to be less otherwise the characters will appear further apart.\n\t\t\t\t\t\t\t\t\tanglePerChar = anglePerChar * radiusPercent\n\n\t\t\t\t\t\t\t\t\t// Next we want the text to be drawn in the middle of the segment, without this it would start at the beginning of the segment.\n\t\t\t\t\t\t\t\t\t// To do this we need to work out how much arc the text will take up in total then subtract half of this from the center\n\t\t\t\t\t\t\t\t\t// of the segment so that it sits centred.\n\t\t\t\t\t\t\t\t\ttotalArc = anglePerChar * lines[i].length\n\n\t\t\t\t\t\t\t\t\t// Now set initial draw angle to half way between the start and end of the segment.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// The initial draw angle is the center of the segment when only one character.\n\t\t\t\t\t\t\t\t\tdrawAngle = seg.startAngle + (seg.endAngle - seg.startAngle) / 2\n\n\t\t\t\t\t\t\t\t\t// To ensure is dead-center the text alignment also needs to be centred.\n\t\t\t\t\t\t\t\t\tthis.ctx.textAlign = 'center'\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Adjust the initial draw angle as needed to take in to account the rotationAngle of the wheel.\n\t\t\t\t\t\t\t\tdrawAngle += this.rotationAngle\n\n\t\t\t\t\t\t\t\t// ----------------------\n\t\t\t\t\t\t\t\t// Now the drawing itself.\n\t\t\t\t\t\t\t\t// Loop for each character in the text.\n\t\t\t\t\t\t\t\tfor (c = 0; c < lines[i].length; c++) {\n\t\t\t\t\t\t\t\t\tthis.ctx.save()\n\n\t\t\t\t\t\t\t\t\tcharacter = lines[i].charAt(c)\n\n\t\t\t\t\t\t\t\t\t// Rotate the wheel to the draw angle as we need to add the character at this location.\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(this.centerX, this.centerY)\n\t\t\t\t\t\t\t\t\tthis.ctx.rotate(this.degToRad(drawAngle))\n\t\t\t\t\t\t\t\t\tthis.ctx.translate(-this.centerX, -this.centerY)\n\n\t\t\t\t\t\t\t\t\t// Now draw the character directly above the center point of the wheel at the appropriate radius.\n\t\t\t\t\t\t\t\t\tif (strokeStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.strokeText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\tif (fillStyle)\n\t\t\t\t\t\t\t\t\t\tthis.ctx.fillText(character, this.centerX, this.centerY - radius + lineOffset)\n\n\t\t\t\t\t\t\t\t\t// Increment the drawAngle by the angle per character so next loop we rotate\n\t\t\t\t\t\t\t\t\t// to the next angle required to draw the character at.\n\t\t\t\t\t\t\t\t\tdrawAngle += anglePerChar\n\n\t\t\t\t\t\t\t\t\tthis.ctx.restore()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment this ready for the next time.\n\t\t\t\t\t\tlineOffset += fontSize\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Restore so all text options are reset ready for the next text.\n\t\t\t\tthis.ctx.restore()\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Converts degrees to radians which is what is used when specifying the angles on HTML5 canvas arcs.\n\t// ====================================================================================================================\n\tdegToRad(d) {\n\t\treturn d * 0.0174532925199432957\n\t}\n\n\t// ====================================================================================================================\n\t// This function sets the center location of the wheel, saves a function call to set x then y.\n\t// ====================================================================================================================\n\tsetCenter(x, y) {\n\t\tthis.centerX = x\n\t\tthis.centerY = y\n\t}\n\n\t// ====================================================================================================================\n\t// This function allows a segment to be added to the wheel. The position of the segment is optional,\n\t// if not specified the new segment will be added to the end of the wheel.\n\t// ====================================================================================================================\n\taddSegment(options, position) {\n\t\t// Create a new segment object passing the options in.\n\t\tnewSegment = new Segment(options)\n\n\t\t// Increment the numSegments property of the class since new segment being added.\n\t\tthis.numSegments++\n\t\tvar segmentPos\n\n\t\t// Work out where to place the segment, the default is simply as a new segment at the end of the wheel.\n\t\tif (typeof position !== 'undefined') {\n\t\t\t// Because we need to insert the segment at this position, not overwrite it, we need to move all segments after this\n\t\t\t// location along one in the segments array, before finally adding this new segment at the specified location.\n\t\t\tfor (var x = this.numSegments; x > position; x--) {\n\t\t\t\tthis.segments[x] = this.segments[x - 1]\n\t\t\t}\n\n\t\t\tthis.segments[position] = newSegment\n\t\t\tsegmentPos = position\n\t\t} else {\n\t\t\tthis.segments[this.numSegments] = newSegment\n\t\t\tsegmentPos = this.numSegments\n\t\t}\n\n\t\t// Since a segment has been added the segment sizes need to be re-computed so call function to do this.\n\t\tthis.updateSegmentSizes()\n\n\t\t// Return the segment object just created in the wheel (JavaScript will return it by reference), so that\n\t\t// further things can be done with it by the calling code if desired.\n\t\treturn this.segments[segmentPos]\n\t}\n\n\t// ====================================================================================================================\n\t// This function must be used if the canvasId is changed as we also need to get the context of the new canvas.\n\t// ====================================================================================================================\n\tsetCanvasId(canvasId) {\n\t\tif (canvasId) {\n\t\t\tthis.canvasId = canvasId\n\t\t\tthis.canvas = document.getElementById(this.canvasId)\n\n\t\t\tif (this.canvas) {\n\t\t\t\tthis.ctx = this.canvas.getContext('2d')\n\t\t\t}\n\t\t} else {\n\t\t\tthis.canvasId = null\n\t\t\tthis.ctx = null\n\t\t\tthis.canvas = null\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function deletes the specified segment from the wheel by removing it from the segments array.\n\t// It then sorts out the other bits such as update of the numSegments.\n\t// ====================================================================================================================\n\tdeleteSegment(position) {\n\t\t// There needs to be at least one segment in order for the wheel to draw, so only allow delete if there\n\t\t// is more than one segment currently left in the wheel.\n\n\t\t//++ check that specifying a position that does not exist - say 10 in a 6 segment wheel does not cause issues.\n\t\tif (this.numSegments > 1) {\n\t\t\t// If the position of the segment to remove has been specified.\n\t\t\tif (typeof position !== 'undefined') {\n\t\t\t\t// The array is to be shortened so we need to move all segments after the one\n\t\t\t\t// to be removed down one so there is no gap.\n\t\t\t\tfor (var x = position; x < this.numSegments; x++) {\n\t\t\t\t\tthis.segments[x] = this.segments[x + 1]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unset the last item in the segments array since there is now one less.\n\t\t\tthis.segments[this.numSegments] = undefined\n\n\t\t\t// Decrement the number of segments,\n\t\t\t// then call function to update the segment sizes.\n\t\t\tthis.numSegments--\n\t\t\tthis.updateSegmentSizes()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function takes the x an the y of a mouse event, such as click or move, and converts the x and the y in to\n\t// co-ordinates on the canvas as the raw values are the x and the y from the top and left of the user's browser.\n\t// ====================================================================================================================\n\twindowToCanvas(x, y) {\n\t\tvar bbox = this.canvas.getBoundingClientRect()\n\n\t\treturn {\n\t\t\tx: Math.floor(x - bbox.left * (this.canvas.width / bbox.width)),\n\t\t\ty: Math.floor(y - bbox.top * (this.canvas.height / bbox.height)),\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// This function returns the segment object located at the specified x and y coordinates on the canvas.\n\t// It is used to allow things to be done with a segment clicked by the user, such as highlight, display or change some values, etc.\n\t// ====================================================================================================================\n\tgetSegmentAt(x, y) {\n\t\tvar foundSegment = null\n\n\t\t// Call function to return segment number.\n\t\tvar segmentNumber = this.getSegmentNumberAt(x, y)\n\n\t\t// If found one then set found segment to pointer to the segment object.\n\t\tif (segmentNumber !== null) {\n\t\t\tfoundSegment = this.segments[segmentNumber]\n\t\t}\n\n\t\treturn foundSegment\n\t}\n\n\t// ====================================================================================================================\n\t// Returns the number of the segment clicked instead of the segment object.\n\t// ====================================================================================================================\n\tgetSegmentNumberAt(x, y) {\n\t\t// KNOWN ISSUE: this does not work correct if the canvas is scaled using css, or has padding, border.\n\t\t// @TODO see if can find a solution at some point, check windowToCanvas working as needed, then below.\n\n\t\t// Call function above to convert the raw x and y from the user's browser to canvas coordinates\n\t\t// i.e. top and left is top and left of canvas, not top and left of the user's browser.\n\t\tvar loc = this.windowToCanvas(x, y)\n\n\t\t// ------------------------------------------\n\t\t// Now start the process of working out the segment clicked.\n\t\t// First we need to figure out the angle of an imaginary line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location (for example a mouse click).\n\t\tvar topBottom\n\t\tvar leftRight\n\t\tvar adjacentSideLength\n\t\tvar oppositeSideLength\n\t\tvar hypotenuseSideLength\n\n\t\t// We will use right triangle maths with the TAN function.\n\t\t// The start of the triangle is the wheel center, the adjacent side is along the x axis, and the opposite side is along the y axis.\n\n\t\t// We only ever use positive numbers to work out the triangle and the center of the wheel needs to be considered as 0 for the numbers\n\t\t// in the maths which is why there is the subtractions below. We also remember what quadrant of the wheel the location is in as we\n\t\t// need this information later to add 90, 180, 270 degrees to the angle worked out from the triangle to get the position around a 360 degree wheel.\n\t\tif (loc.x > this.centerX) {\n\t\t\tadjacentSideLength = loc.x - this.centerX\n\t\t\tleftRight = 'R' // Location is in the right half of the wheel.\n\t\t} else {\n\t\t\tadjacentSideLength = this.centerX - loc.x\n\t\t\tleftRight = 'L' // Location is in the left half of the wheel.\n\t\t}\n\n\t\tif (loc.y > this.centerY) {\n\t\t\toppositeSideLength = loc.y - this.centerY\n\t\t\ttopBottom = 'B' // Bottom half of wheel.\n\t\t} else {\n\t\t\toppositeSideLength = this.centerY - loc.y\n\t\t\ttopBottom = 'T' // Top Half of wheel.\n\t\t}\n\n\t\t// Now divide opposite by adjacent to get tan value.\n\t\tvar tanVal = oppositeSideLength / adjacentSideLength\n\n\t\t// Use the tan function and convert results to degrees since that is what we work with.\n\t\tvar result = (Math.atan(tanVal) * 180) / Math.PI\n\t\tvar locationAngle = 0\n\n\t\t// We also need the length of the hypotenuse as later on we need to compare this to the outerRadius of the segment / circle.\n\t\thypotenuseSideLength = Math.sqrt(\n\t\t\toppositeSideLength * oppositeSideLength + adjacentSideLength * adjacentSideLength\n\t\t)\n\n\t\t// ------------------------------------------\n\t\t// Now to make sense around the wheel we need to alter the values based on if the location was in top or bottom half\n\t\t// and also right or left half of the wheel, by adding 90, 180, 270 etc. Also for some the initial locationAngle needs to be inverted.\n\t\tif (topBottom == 'T' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(90 - result)\n\t\t} else if (topBottom == 'B' && leftRight == 'R') {\n\t\t\tlocationAngle = Math.round(result + 90)\n\t\t} else if (topBottom == 'B' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(90 - result + 180)\n\t\t} else if (topBottom == 'T' && leftRight == 'L') {\n\t\t\tlocationAngle = Math.round(result + 270)\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// And now we have to adjust to make sense when the wheel is rotated from the 0 degrees either\n\t\t// positive or negative and it can be many times past 360 degrees.\n\t\tif (this.rotationAngle != 0) {\n\t\t\tvar rotatedPosition = this.getRotationPosition()\n\n\t\t\t// So we have this, now we need to alter the locationAngle as a result of this.\n\t\t\tlocationAngle = locationAngle - rotatedPosition\n\n\t\t\t// If negative then take the location away from 360.\n\t\t\tif (locationAngle < 0) {\n\t\t\t\tlocationAngle = 360 - Math.abs(locationAngle)\n\t\t\t}\n\t\t}\n\n\t\t// ------------------------------------------\n\t\t// OK, so after all of that we have the angle of a line between the centerX and centerY of the wheel and\n\t\t// the X and Y of the location on the canvas where the mouse was clicked. Now time to work out the segment\n\t\t// this corresponds to. We can use the segment start and end angles for this.\n\t\tvar foundSegmentNumber = null\n\n\t\tfor (var x = 1; x <= this.numSegments; x++) {\n\t\t\t// Due to segments sharing start and end angles, if line is clicked will pick earlier segment.\n\t\t\tif (locationAngle >= this.segments[x].startAngle && locationAngle <= this.segments[x].endAngle) {\n\t\t\t\t// To ensure that a click anywhere on the canvas in the segment direction will not cause a\n\t\t\t\t// segment to be matched, as well as the angles, we need to ensure the click was within the radius\n\t\t\t\t// of the segment (or circle if no segment radius).\n\n\t\t\t\t// If the hypotenuseSideLength (length of location from the center of the wheel) is with the radius\n\t\t\t\t// then we can assign the segment to the found segment and break out the loop.\n\n\t\t\t\t// Have to take in to account hollow wheels (doughnuts) so check is greater than innerRadius as\n\t\t\t\t// well as less than or equal to the outerRadius of the wheel.\n\t\t\t\tif (hypotenuseSideLength >= this.innerRadius && hypotenuseSideLength <= this.outerRadius) {\n\t\t\t\t\tfoundSegmentNumber = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Finally return the number.\n\t\treturn foundSegmentNumber\n\t}\n\n\t// ====================================================================================================================\n\t// Returns a reference to the segment that is at the location of the pointer on the wheel.\n\t// ====================================================================================================================\n\tgetIndicatedSegment() {\n\t\t// Call function below to work this out and return the prizeNumber.\n\t\tvar prizeNumber = this.getIndicatedSegmentNumber()\n\n\t\t// Then simply return the segment in the segments array at that position.\n\t\treturn this.segments[prizeNumber]\n\t}\n\n\t// ====================================================================================================================\n\t// Works out the segment currently pointed to by the pointer of the wheel. Normally called when the spinning has stopped\n\t// to work out the prize the user has won. Returns the number of the segment in the segments array.\n\t// ====================================================================================================================\n\tgetIndicatedSegmentNumber() {\n\t\tvar indicatedPrize = 0\n\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\tif (relativeAngle < 0) {\n\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t}\n\n\t\t// Now we can work out the prize won by seeing what prize segment startAngle and endAngle the relativeAngle is between.\n\t\tfor (var x = 1; x < this.segments.length; x++) {\n\t\t\tif (relativeAngle >= this.segments[x]['startAngle'] && relativeAngle <= this.segments[x]['endAngle']) {\n\t\t\t\tindicatedPrize = x\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn indicatedPrize\n\t}\n\n\t// ====================================================================================================================\n\t// Works out what Pin around the wheel is considered the current one which is the one which just passed the pointer.\n\t// Used to work out if the pin has changed during the animation to tigger a sound.\n\t// ====================================================================================================================\n\tgetCurrentPinNumber() {\n\t\tvar currentPin = 0\n\n\t\tif (this.pins) {\n\t\t\tvar rawAngle = this.getRotationPosition()\n\n\t\t\t// Now we have the angle of the wheel, but we need to take in to account where the pointer is because\n\t\t\t// will not always be at the 12 o'clock 0 degrees location.\n\t\t\tvar relativeAngle = Math.floor(this.pointerAngle - rawAngle)\n\n\t\t\tif (relativeAngle < 0) {\n\t\t\t\trelativeAngle = 360 - Math.abs(relativeAngle)\n\t\t\t}\n\n\t\t\t// Work out the angle of the pins as this is simply 360 / the number of pins as they space evenly around.\n\t\t\tvar pinSpacing = 360 / this.pins.number\n\t\t\tvar totalPinAngle = 0\n\n\t\t\t// Now we can work out the pin by seeing what pins relativeAngle is between.\n\t\t\tfor (var x = 0; x < this.pins.number; x++) {\n\t\t\t\tif (relativeAngle >= totalPinAngle && relativeAngle <= totalPinAngle + pinSpacing) {\n\t\t\t\t\tcurrentPin = x\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ttotalPinAngle += pinSpacing\n\t\t\t}\n\n\t\t\t// Now if rotating clockwise we must add 1 to the current pin as we want the pin which has just passed\n\t\t\t// the pointer to be returned as the current pin, not the start of the one we are between.\n\t\t\tif (this.animation.direction == 'clockwise') {\n\t\t\t\tcurrentPin++\n\n\t\t\t\tif (currentPin > this.pins.number) {\n\t\t\t\t\tcurrentPin = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn currentPin\n\t}\n\n\t// ==================================================================================================================================================\n\t// Returns the rotation angle of the wheel corrected to 0-360 (i.e. removes all the multiples of 360).\n\t// ==================================================================================================================================================\n\tgetRotationPosition() {\n\t\tvar rawAngle = this.rotationAngle // Get current rotation angle of wheel.\n\n\t\t// If positive work out how many times past 360 this is and then take the floor of this off the rawAngle.\n\t\tif (rawAngle >= 0) {\n\t\t\tif (rawAngle > 360) {\n\t\t\t\t// Get floor of the number of times past 360 degrees.\n\t\t\t\tvar timesPast360 = Math.floor(rawAngle / 360)\n\n\t\t\t\t// Take all this extra off to get just the angle 0-360 degrees.\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360\n\t\t\t}\n\t\t} else {\n\t\t\t// Is negative, need to take off the extra then convert in to 0-360 degree value\n\t\t\t// so if, for example, was -90 then final value will be (360 - 90) = 270 degrees.\n\t\t\tif (rawAngle < -360) {\n\t\t\t\tvar timesPast360 = Math.ceil(rawAngle / 360) // Ceil when negative.\n\n\t\t\t\trawAngle = rawAngle - 360 * timesPast360 // Is minus because dealing with negative.\n\t\t\t}\n\n\t\t\trawAngle = 360 + rawAngle // Make in the range 0-360. Is plus because raw is still negative.\n\t\t}\n\n\t\treturn rawAngle\n\t}\n\n\t// ==================================================================================================================================================\n\t// This function starts the wheel's animation by using the properties of the animation object of of the wheel to begin the a greensock tween.\n\t// ==================================================================================================================================================\n\tstartAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Call function to compute the animation properties.\n\t\t\tthis.computeAnimation()\n\n\t\t\t// Set this global variable to this object as an external function is required to call the draw() function on the wheel\n\t\t\t// each loop of the animation as Greensock cannot call the draw function directly on this class.\n\t\t\twinwheelToDrawDuringAnimation = this\n\n\t\t\t// Put together the properties of the greesock animation.\n\t\t\tvar properties = new Array(null)\n\t\t\tproperties[this.animation.propertyName] = this.animation.propertyValue // Here we set the property to be animated and its value.\n\t\t\tproperties['yoyo'] = this.animation.yoyo // Set others.\n\t\t\tproperties['repeat'] = this.animation.repeat\n\t\t\tproperties['ease'] = this.animation.easing\n\t\t\tproperties['onUpdate'] = winwheelAnimationLoop // Call function to re-draw the canvas.\n\t\t\tproperties['onComplete'] = winwheelStopAnimation // Call function to perform actions when animation has finished.\n\n\t\t\t// Do the tween animation passing the properties from the animation object as an array of key => value pairs.\n\t\t\t// Keep reference to the tween object in the wheel as that allows pausing, resuming, and stopping while the animation is still running.\n\t\t\tthis.tween = TweenMax.to(this, this.animation.duration, properties)\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Use same function function which needs to be outside the class for the callback when it stops because is finished.\n\t// ==================================================================================================================================================\n\tstopAnimation(canCallback) {\n\t\t// @TODO as part of multiwheel, need to work out how to stop the tween for a single wheel but allow others to continue.\n\n\t\t// We can kill the animation using our tween object.\n\t\tif (winwheelToDrawDuringAnimation) {\n\t\t\twinwheelToDrawDuringAnimation.tween.kill()\n\n\t\t\t// Call the callback function.\n\t\t\twinwheelStopAnimation(canCallback)\n\t\t}\n\n\t\t// Ensure the winwheelToDrawDuringAnimation is set to this class.\n\t\twinwheelToDrawDuringAnimation = this\n\t}\n\n\t// ==================================================================================================================================================\n\t// Pause animation by telling tween to pause.\n\t// ==================================================================================================================================================\n\tpauseAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.pause()\n\t\t}\n\t}\n\n\t// ==================================================================================================================================================\n\t// Resume the animation by telling tween to continue playing it.\n\t// ==================================================================================================================================================\n\tresumeAnimation() {\n\t\tif (this.tween) {\n\t\t\tthis.tween.play()\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Called at the beginning of the startAnimation function and computes the values needed to do the animation\n\t// before it starts. This allows the developer to change the animation properties after the wheel has been created\n\t// and have the animation use the new values of the animation properties.\n\t// ====================================================================================================================\n\tcomputeAnimation() {\n\t\tif (this.animation) {\n\t\t\t// Set the animation parameters for the specified animation type including some sensible defaults if values have not been specified.\n\t\t\tif (this.animation.type == 'spinOngoing') {\n\t\t\t\t// When spinning the rotationAngle is the wheel property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = -1 // -1 means it will repeat forever.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Linear.easeNone'\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// We need to calculate the propertyValue and this is the spins * 360 degrees.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\t// If the direction is anti-clockwise then make the property value negative.\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinToStop') {\n\t\t\t\t// Spin to stop the rotation angle is affected.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 0 // As this is spin to stop we don't normally want it repeated.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power3.easeOut' // This easing is fast start and slows over time.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\t// If the stop angle has not been specified then pick random between 0 and 359.\n\t\t\t\t\tthis.animation._stopAngle = Math.floor(Math.random() * 359)\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered because the wheel spins past 0 without\n\t\t\t\t\t// this it would indicate the prize on the opposite side of the wheel. We aslo need to take in to account\n\t\t\t\t\t// the pointerAngle as the stop angle needs to be relative to that.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle + this.pointerAngle\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = false\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'spinAndBack') {\n\t\t\t\t// This is basically is a spin for a number of times then the animation reverses and goes back to start.\n\t\t\t\t// If a repeat is specified then this can be used to make the wheel \"rock\" left and right.\n\n\t\t\t\t// Again this is a spin so the rotationAngle the property which is animated.\n\t\t\t\tthis.animation.propertyName = 'rotationAngle'\n\n\t\t\t\tif (this.animation.spins == null) {\n\t\t\t\t\tthis.animation.spins = 5\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.repeat == null) {\n\t\t\t\t\tthis.animation.repeat = 1 // This needs to be set to at least 1 in order for the animation to reverse.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.easing == null) {\n\t\t\t\t\tthis.animation.easing = 'Power2.easeInOut' // This is slow at the start and end and fast in the middle.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.yoyo == null) {\n\t\t\t\t\tthis.animation.yoyo = true // This needs to be set to true to have the animation reverse back like a yo-yo.\n\t\t\t\t}\n\n\t\t\t\tif (this.animation.stopAngle == null) {\n\t\t\t\t\tthis.animation._stopAngle = 0\n\t\t\t\t} else {\n\t\t\t\t\t// We need to set the internal to 360 minus what the user entered\n\t\t\t\t\t// because the wheel spins past 0 without this it would indicate the\n\t\t\t\t\t// prize on the opposite side of the wheel.\n\t\t\t\t\tthis.animation._stopAngle = 360 - this.animation.stopAngle\n\t\t\t\t}\n\n\t\t\t\t// The property value is the spins * 360 then plus or minus the stopAngle depending on if the rotation is clockwise or anti-clockwise.\n\t\t\t\tthis.animation.propertyValue = this.animation.spins * 360\n\n\t\t\t\tif (this.animation.direction == 'anti-clockwise') {\n\t\t\t\t\tthis.animation.propertyValue = 0 - this.animation.propertyValue\n\n\t\t\t\t\t// Also if the value is anti-clockwise we need subtract the stopAngle (but to get the wheel to stop in the correct\n\t\t\t\t\t// place this is 360 minus the stop angle as the wheel is rotating backwards).\n\t\t\t\t\tthis.animation.propertyValue -= 360 - this.animation._stopAngle\n\t\t\t\t} else {\n\t\t\t\t\t// Add the stopAngle to the propertyValue as the wheel must rotate around to this place and stop there.\n\t\t\t\t\tthis.animation.propertyValue += this.animation._stopAngle\n\t\t\t\t}\n\t\t\t} else if (this.animation.type == 'custom') {\n\t\t\t\t// Do nothing as all values must be set by the developer in the parameters\n\t\t\t\t// especially the propertyName and propertyValue.\n\t\t\t}\n\t\t}\n\t}\n\n\t// ====================================================================================================================\n\t// Calculates and returns a random stop angle inside the specified segment number. Value will always be 1 degree inside\n\t// the start and end of the segment to avoid issue with the segment overlap.\n\t// ====================================================================================================================\n\tgetRandomForSegment(segmentNumber) {\n\t\tvar stopAngle = 0\n\n\t\tif (segmentNumber) {\n\t\t\tif (typeof this.segments[segmentNumber] !== 'undefined') {\n\t\t\t\tvar startAngle = this.segments[segmentNumber].startAngle\n\t\t\t\tvar endAngle = this.segments[segmentNumber].endAngle\n\t\t\t\tvar range = endAngle - startAngle - 2\n\n\t\t\t\tif (range > 0) {\n\t\t\t\t\tstopAngle = startAngle + 1 + Math.floor(Math.random() * range)\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Segment size is too small to safely get random angle inside it')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log('Segment ' + segmentNumber + ' undefined')\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('Segment number not specified')\n\t\t}\n\n\t\treturn stopAngle\n\t}\n}\n\n// ====================================================================================================================\n// Class for the wheel pins.\n// ====================================================================================================================\nexport class Pin {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tvisible: true, // In future there might be some functionality related to the pins even if they are not displayed.\n\t\t\tnumber: 36, // The number of pins. These are evenly distributed around the wheel.\n\t\t\touterRadius: 3, // Radius of the pins which determines their size.\n\t\t\tfillStyle: 'grey', // Fill colour of the pins.\n\t\t\tstrokeStyle: 'black', // Line colour of the pins.\n\t\t\tlineWidth: 1, // Line width of the pins.\n\t\t\tmargin: 3, // The space between outside edge of the wheel and the pins.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for the wheel spinning animation which like a segment becomes a property of the wheel.\n// ====================================================================================================================\nexport class Animation {\n\tconstructor(options) {\n\t\t// Most of these options are null because the defaults are different depending on the type of animation.\n\t\tvar defaultOptions = {\n\t\t\ttype: 'spinOngoing', // For now there are only supported types are spinOngoing (continuous), spinToStop, spinAndBack, custom.\n\t\t\tdirection: 'clockwise', // clockwise or anti-clockwise.\n\t\t\tpropertyName: null, // The name of the winning wheel property to be affected by the animation.\n\t\t\tpropertyValue: null, // The value the property is to be set to at the end of the animation.\n\t\t\tduration: 10, // Duration of the animation.\n\t\t\tyoyo: false, // If the animation is to reverse back again i.e. yo-yo.\n\t\t\trepeat: null, // The number of times the animation is to repeat, -1 will cause it to repeat forever.\n\t\t\teasing: null, // The easing to use for the animation, default is the best for spin to stop. Use Linear.easeNone for no easing.\n\t\t\tstopAngle: null, // Used for spinning, the angle at which the wheel is to stop.\n\t\t\tspins: null, // Used for spinning, the number of complete 360 degree rotations the wheel is to do.\n\t\t\tclearTheCanvas: null, // If set to true the canvas will be cleared before the wheel is re-drawn, false it will not, null the animation will abide by the value of this property for the parent wheel object.\n\t\t\tcallbackFinished: null, // Function to callback when the animation has finished.\n\t\t\tcallbackBefore: null, // Function to callback before the wheel is drawn each animation loop.\n\t\t\tcallbackAfter: null, // Function to callback after the wheel is drawn each animation loop.\n\t\t\tcallbackSound: null, // Function to callback if a sound should be triggered on change of segment or pin.\n\t\t\tsoundTrigger: 'segment', // Sound trigger type. Default is segment which triggers when segment changes, can be pin if to trigger when pin passes the pointer.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// ====================================================================================================================\n// Class for segments. When creating a json of options can be passed in.\n// ====================================================================================================================\nexport class Segment {\n\tconstructor(options) {\n\t\t// Define default options for segments, most are null so that the global defaults for the wheel\n\t\t// are used if the values for a particular segment are not specifically set.\n\t\tvar defaultOptions = {\n\t\t\tsize: null, // Leave null for automatic. Valid values are degrees 0-360. Use percentToDegrees function if needed to convert.\n\t\t\ttext: '', // Default is blank.\n\t\t\tfillStyle: null, // If null for the rest the global default will be used.\n\t\t\tstrokeStyle: null,\n\t\t\tlineWidth: null,\n\t\t\ttextFontFamily: null,\n\t\t\ttextFontSize: null,\n\t\t\ttextFontWeight: null,\n\t\t\ttextOrientation: null,\n\t\t\ttextAlignment: null,\n\t\t\ttextDirection: null,\n\t\t\ttextMargin: null,\n\t\t\ttextFillStyle: null,\n\t\t\ttextStrokeStyle: null,\n\t\t\ttextLineWidth: null,\n\t\t\timage: null, // Name/path to the image\n\t\t\timageDirection: null, // Direction of the image, can be set globally for the whole wheel.\n\t\t\timgData: null, // Image object created here and loaded with image data.\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') this[key] = options[key]\n\t\t\telse this[key] = defaultOptions[key]\n\t\t}\n\n\t\t// Also loop though the passed in options and add anything specified not part of the class in to it as a property.\n\t\t// This allows the developer to easily add properties to segments at construction time.\n\t\tif (options != null) {\n\t\t\tfor (var key in options) {\n\t\t\t\tif (typeof this[key] === 'undefined') {\n\t\t\t\t\tthis[key] = options[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// There are 2 additional properties which are set by the code, so need to define them here.\n\t\t// They are not in the default options because they are not something that should be set by the user,\n\t\t// the values are updated every time the updateSegmentSizes() function is called.\n\t\tthis.startAngle = 0\n\t\tthis.endAngle = 0\n\t}\n\n\t// ====================================================================================================================\n\t// Changes an image for a segment by setting a callback to render the wheel once the image has loaded.\n\t// ====================================================================================================================\n\tchangeImage(image, imageDirection) {\n\t\t// Change image name, blank image data.\n\t\tthis.image = image\n\t\tthis.imgData = null\n\n\t\t// Set direction.\n\t\tif (imageDirection) {\n\t\t\tthis.imageDirection = imageDirection\n\t\t}\n\n\t\t// Set imgData to a new image object, change set callback and change src (just like in wheel constructor).\n\t\twinhweelAlreadyDrawn = false\n\t\tthis.imgData = new Image()\n\t\tthis.imgData.onload = winwheelLoadedImage\n\t\tthis.imgData.src = this.image\n\t}\n}\n\n// ====================================================================================================================\n// Class that is created as property of the wheel. Draws line from center of the wheel out to edge of canvas to\n// indicate where the code thinks the pointer location is. Helpful to get alignment correct esp when using images.\n// ====================================================================================================================\nexport class PointerGuide {\n\tconstructor(options) {\n\t\tvar defaultOptions = {\n\t\t\tdisplay: false,\n\t\t\tstrokeStyle: 'red',\n\t\t\tlineWidth: 3,\n\t\t}\n\n\t\t// Now loop through the default options and create properties of this class set to the value for\n\t\t// the option passed in if a value was, or if not then set the value of the default.\n\t\tfor (var key in defaultOptions) {\n\t\t\tif (options != null && typeof options[key] !== 'undefined') {\n\t\t\t\tthis[key] = options[key]\n\t\t\t} else {\n\t\t\t\tthis[key] = defaultOptions[key]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function takes the percent 0-100 and returns the number of degrees 0-360 this equates to.\n// ====================================================================================================================\nfunction winwheelPercentToDegrees(percentValue) {\n\tvar degrees = 0\n\n\tif (percentValue > 0 && percentValue <= 100) {\n\t\tvar divider = percentValue / 100\n\t\tdegrees = 360 * divider\n\t}\n\n\treturn degrees\n}\n\n// ====================================================================================================================\n// In order for the wheel to be re-drawn during the spin animation the function greesock calls needs to be outside\n// of the class as for some reason it errors if try to call winwheel.draw() directly.\n// ====================================================================================================================\nfunction winwheelAnimationLoop() {\n\tif (winwheelToDrawDuringAnimation) {\n\t\t// Check if the clearTheCanvas is specified for this animation, if not or it is not false then clear the canvas.\n\t\tif (winwheelToDrawDuringAnimation.animation.clearTheCanvas != false) {\n\t\t\twinwheelToDrawDuringAnimation.ctx.clearRect(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.width,\n\t\t\t\twinwheelToDrawDuringAnimation.canvas.height\n\t\t\t)\n\t\t}\n\n\t\tvar callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore\n\t\tvar callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter\n\n\t\t// If there is a callback function which is supposed to be called before the wheel is drawn then do that.\n\t\tif (callbackBefore != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackBefore === 'function') {\n\t\t\t\tcallbackBefore()\n\t\t\t} else {\n\t\t\t\teval(callbackBefore)\n\t\t\t}\n\t\t}\n\n\t\t// Call code to draw the wheel, pass in false as we never want it to clear the canvas as that would wipe anything drawn in the callbackBefore.\n\t\twinwheelToDrawDuringAnimation.draw(false)\n\n\t\t// If there is a callback function which is supposed to be called after the wheel has been drawn then do that.\n\t\tif (callbackAfter != null) {\n\t\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\t\tif (typeof callbackAfter === 'function') {\n\t\t\t\tcallbackAfter()\n\t\t\t} else {\n\t\t\t\teval(callbackAfter)\n\t\t\t}\n\t\t}\n\n\t\t// If there is a sound callback then call a function which figures out if the sound should be triggered\n\t\t// and if so then call the function specified by the developer.\n\t\tif (winwheelToDrawDuringAnimation.animation.callbackSound) {\n\t\t\twinwheelTriggerSound()\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// This function figures out if the callbackSound function needs to be called by working out if the segment or pin\n// has changed since the last animation loop.\n// ====================================================================================================================\nfunction winwheelTriggerSound() {\n\t// If this property does not exist then add it as a property of the winwheel.\n\tif (winwheelToDrawDuringAnimation.hasOwnProperty('_lastSoundTriggerNumber') == false) {\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0\n\t}\n\n\tvar callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound\n\tvar currentTriggerNumber = 0\n\n\t// Now figure out if the sound callback should be called depending on the sound trigger type.\n\tif (winwheelToDrawDuringAnimation.animation.soundTrigger == 'pin') {\n\t\t// So for the pin type we need to work out which pin we are between.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getCurrentPinNumber()\n\t} else {\n\t\t// Check on the change of segment by working out which segment we are in.\n\t\t// We can utilise the existing getIndiatedSegmentNumber function.\n\t\tcurrentTriggerNumber = winwheelToDrawDuringAnimation.getIndicatedSegmentNumber()\n\t}\n\n\t// If the current number is not the same as last time then call the sound callback.\n\tif (currentTriggerNumber != winwheelToDrawDuringAnimation._lastSoundTriggerNumber) {\n\t\t// If the property is a function then call it, otherwise eval the proptery as javascript code.\n\t\tif (typeof callbackSound === 'function') {\n\t\t\tcallbackSound()\n\t\t} else {\n\t\t\teval(callbackSound)\n\t\t}\n\n\t\t// Also update the last sound trigger with the current number.\n\t\twinwheelToDrawDuringAnimation._lastSoundTriggerNumber = currentTriggerNumber\n\t}\n}\n\n// ====================================================================================================================\n// This function is called-back when the greensock animation has finished.\n// ====================================================================================================================\nvar winwheelToDrawDuringAnimation = null // This global is set by the winwheel class to the wheel object to be re-drawn.\n\nfunction winwheelStopAnimation(canCallback) {\n\t// When the animation is stopped if canCallback is not false then try to call the callback.\n\t// false can be passed in to stop the after happening if the animation has been stopped before it ended normally.\n\tif (canCallback != false) {\n\t\tvar callback = winwheelToDrawDuringAnimation.animation.callbackFinished\n\n\t\tif (callback != null) {\n\t\t\t// If the callback is a function then call it, otherwise evaluate the property as javascript code.\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\t// Pass back the indicated segment as 99% of the time you will want to know this to inform the user of their prize.\n\t\t\t\tcallback(winwheelToDrawDuringAnimation.getIndicatedSegment())\n\t\t\t} else {\n\t\t\t\teval(callback)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ====================================================================================================================\n// Called after the image has loaded for each segment. Once all the images are loaded it then calls the draw function\n// on the wheel to render it. Used in constructor and also when a segment image is changed.\n// ====================================================================================================================\nvar winhweelAlreadyDrawn = false\n\nfunction winwheelLoadedImage() {\n\t// Prevent multiple drawings of the wheel which ocurrs without this check due to timing of function calls.\n\tif (winhweelAlreadyDrawn == false) {\n\t\t// Set to 0.\n\t\tvar winwheelImageLoadCount = 0\n\n\t\t// Loop though all the segments of the wheel and check if image data loaded, if so increment counter.\n\t\tfor (var i = 1; i <= winwheelToDrawDuringAnimation.numSegments; i++) {\n\t\t\t// Check the image data object is not null and also that the image has completed loading by checking\n\t\t\t// that a property of it such as the height has some sort of true value.\n\t\t\tif (\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData != null &&\n\t\t\t\twinwheelToDrawDuringAnimation.segments[i].imgData.height\n\t\t\t) {\n\t\t\t\twinwheelImageLoadCount++\n\t\t\t}\n\t\t}\n\n\t\t// If number of images loaded matches the segments then all the images for the wheel are loaded.\n\t\tif (winwheelImageLoadCount == winwheelToDrawDuringAnimation.numSegments) {\n\t\t\t// Call draw function to render the wheel.\n\t\t\twinhweelAlreadyDrawn = true\n\t\t\twinwheelToDrawDuringAnimation.draw()\n\t\t}\n\t}\n}\n/* eslint-enabled */\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('NavbarComponent'),_c('div',{attrs:{\"id\":\"app\"}},[_c('GamesComponent')],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('div',{staticClass:\"flex flow-row justify-around\"},[_c('div',{staticClass:\"place-items-center px-8 pb-8 mb-4\"},[_c('WheelComponent')],1),_c('div',{staticClass:\"place-items-center\"},[_c('NameChooser')],1)])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:\"vue-winwheel\"},[_c('div',{staticClass:\"bg-white shadow-md rounded px-8 pt-4 pb-8 mb-4\"},[(_vm.formattedPlayers.length > 0)?_c('div',[_c('div',{staticClass:\"mobile-container\"},[_c('div',{staticClass:\"wheel-wrapper\"},[_vm._m(0),_c('div',{staticClass:\"button-wrapper\"},[(!_vm.loadingPrize && !_vm.wheelSpinning)?_c('a',{staticClass:\"btn btn-play\",attrs:{\"href\":\"#\"},on:{\"click\":function($event){$event.preventDefault();return _vm.startSpin()}}},[_vm._v(\"SPIN!\")]):_vm._e()])])]),(_vm.winningPlayer)?_c('div',{staticClass:\"custom-modal modal-mask\",attrs:{\"id\":\"modalSpinwheel\"}},[_c('div',{attrs:{\"slot\":\"body\"},slot:\"body\"},[_c('a',{staticClass:\"modal-dismiss\",attrs:{\"href\":\"\"},on:{\"click\":function($event){$event.preventDefault();return _vm.hidePrize()}}},[_c('i',{staticClass:\"icon_close\"})]),_c('h2',[_vm._v(\" Yay ! \"+_vm._s(_vm.prizeName)+\" is the speaker. \")])])]):_vm._e()]):_c('div',{staticClass:\"px-8 pt-6 pb-8 mb-4\"},[_vm._v(\" Aucun joueur de sélectionné \")])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"canvas-wrapper\"},[_c('canvas',{attrs:{\"id\":\"canvas\",\"width\":\"310\",\"height\":\"310\"}},[_c('p',{staticStyle:{\"{color\":\"white}\"},attrs:{\"align\":\"center\"}},[_vm._v(\"Sorry, your browser doesn't support canvas. Please try Google Chrome.\")])])])}]\n\nexport { render, staticRenderFns }","<template>\n  <section class=\"vue-winwheel\">\n  <div class=\"bg-white shadow-md rounded px-8 pt-4 pb-8 mb-4\">\n    <div v-if=\"formattedPlayers.length > 0\">\n      <div class=\"mobile-container\">\n        <div class=\"wheel-wrapper\">\n          <div class=\"canvas-wrapper\">\n            <canvas id=\"canvas\" width=\"310\" height=\"310\">\n              <p style=\"{color: white}\" align=\"center\">Sorry, your browser doesn't support canvas. Please try Google Chrome.</p>\n            </canvas>\n          </div>\n          <div class=\"button-wrapper\">\n            <a class=\"btn btn-play\" href=\"#\" @click.prevent=\"startSpin()\" v-if=\"!loadingPrize && !wheelSpinning\">SPIN!</a>\n          </div>\n        </div>\n      </div>\n      <div class=\"custom-modal modal-mask\" id=\"modalSpinwheel\" v-if=\"winningPlayer\">\n        <div slot=\"body\">\n          <a href=\"\" @click.prevent=\"hidePrize()\" class=\"modal-dismiss\">\n            <i class=\"icon_close\"></i>\n          </a>\n          <h2>\n            Yay ! {{prizeName}} is the speaker.\n          </h2>\n        </div>\n      </div>\n    </div>\n      <div class=\"px-8 pt-6 pb-8 mb-4\" v-else>\n        Aucun joueur de sélectionné\n      </div>\n    </div>\n  </section>\n\n</template>\n\n\n<script>\nimport * as Winwheel from '../../../javascript/Winwheel'\nimport { mapState } from 'vuex'\n\nconst defaultColors = [\n  {\n    textFillStyle: '#fff',\n    fillStyle: '#267257',\n  },\n  {\n    textFillStyle: '#fff',\n    fillStyle: '#2A4D6F',\n  },\n  {\n    textFillStyle: '#2A4D6F',\n    fillStyle: '#fff',\n  },\n]\n\n\n\nexport default {\n  name: 'WheelComponent',\n  data () {\n    return {\n      loadingPrize: false,\n      theWheel: null,\n      winningPlayer: false,\n      wheelSpinning: false,\n      WinWheelOptions: {\n        textFontSize: 14,\n        outterRadius: 410,\n        innerRadius: 25,\n        lineWidth: 8,\n        animation: {\n          type: 'spinOngoing',\n          duration: 0.5\n        }\n      }\n    }\n  },\n  methods: {\n    showPrize () {\n      this.winningPlayer = true\n    },\n    hidePrize () {\n      this.winningPlayer = false\n    },\n    startSpin () {\n      this.hidePrize();\n      if (this.wheelSpinning === false) {\n        this.theWheel.startAnimation()\n        this.wheelSpinning = true\n        this.theWheel = new Winwheel.Winwheel({\n          ...this.WinWheelOptions,\n          numSegments: this.formattedPlayers.length,\n          segments: this.formattedPlayers,\n          animation: {\n            type: 'spinToStop',\n            duration: 2,\n            spins: 10,\n            callbackFinished: this.onFinishSpin\n          }\n        })\n        // example input prize number get from Backend\n        // Important thing is to set the stopAngle of the animation before stating the spin.\n\n        var prizeNumber = Math.floor(Math.random() * this.formattedPlayers.length) // or just get from Backend\n        var stopAt = 360 / this.formattedPlayers.length * prizeNumber - 360 / this.formattedPlayers.length / 2 // center pin\n        // var stopAt = 360 / this.segments.length * prizeNumber - Math.floor(Math.random() * 60) //random location\n        this.theWheel.animation.stopAngle = stopAt\n        this.theWheel.animation.callbackSound = () => {\n          this.playSound();\n        };\n        this.theWheel.startAnimation()\n        this.wheelSpinning = false\n      }\n    },\n    formatColors(index) {\n      let desiredIndex = 0;\n      for (let i = 3; i >= 1; i--) {\n        if (index % i === 0) {\n          desiredIndex = i - 1;\n          break\n        }\n      }\n      return defaultColors[desiredIndex];\n    },\n    resetWheel () {\n      this.theWheel = new Winwheel.Winwheel({\n        ...this.WinWheelOptions,\n        numSegments: this.formattedPlayers.length,\n        segments: this.formattedPlayers,\n        animation: {\n          type: 'spinToStop',\n          duration: 2,\n          spins: 10,\n        }\n      })\n\n      if (this.wheelSpinning) {\n        this.theWheel.stopAnimation(false) // Stop the animation, false as param so does not call callback function.\n      }\n\n      this.theWheel.rotationAngle = 0 // Re-set the wheel angle to 0 degrees.\n      this.theWheel.draw() // Call draw to render changes to the wheel.\n      this.wheelSpinning = false // Reset to false to power buttons and spin can be clicked again.\n    },\n    initSpin () {\n      this.loadingPrize = true\n      this.resetWheel()\n      this.loadingPrize = false\n    },\n    onFinishSpin (indicatedSegment) {\n      this.prizeName = indicatedSegment.text\n      this.showPrize()\n    },\n    playSound() {\n      return;\n    }\n  },\n  computed: {\n    ...mapState(['players']),\n    formattedPlayers() {\n      if (this.players.length === 0) return [];\n\n      return this.players\n        .filter(player => player.displayed)\n        .map((player, i) => {\n          return {\n            ...this.formatColors(i),\n            text: player.name,\n            uniqId: player.uniqId,\n            displayed: player.displayed,\n          }\n      });\n    },\n  },\n  watch: {\n    formattedPlayers() {\n      this.resetWheel();\n      this.hidePrize();\n    }\n  },\n  mounted () {\n    this.resetWheel()\n  },\n}\n\n</script>\n\n<style scoped>\n.vue-winwheel {\n  position: fixed;\n\ttext-align: center;\n\tbackground-image: none;\n\tbackground-size: cover;\n\tbackground-position: center bottom;\n\tbackground-repeat: no-repeat;\n}\n.vue-winwheel h1 {\n\tcolor: #2A4D6F;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 36px;\n\tline-height: 90px;\n\tletter-spacing: 4px;\n\tmargin: 0;\n}\n.vue-winwheel h2 {\n\tmargin: 0;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content {\n\twidth: calc(100vw - 30px);\n\tpadding-top: 52px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content h2 {\n\ttext-transform: uppercase;\n\tcolor: #2A4D6F;\n\tmargin-bottom: 16px;\n\tmargin-top: 0;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 18px;\n\tletter-spacing: 1.1px;\n\tmargin: 0;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p {\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tfont-size: 14px;\n\tcolor: black;\n\ttext-align: center;\n\tline-height: 25px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content p strong {\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss {\n\ttop: 12px;\n\tright: 12px;\n}\n.vue-winwheel #modalSpinwheel.custom-modal .content-wrapper .content .modal-dismiss i.icon_close {\n\tfont-size: 30px;\n\tcolor: #2A4D6F;\n}\n.vue-winwheel canvas#canvas {\n\tposition: relative;\n}\n.vue-winwheel .canvas-wrapper {\n\tposition: relative;\n}\n.vue-winwheel .canvas-wrapper:after {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 42px;\n\tbackground: #2A4D6F;\n\theight: 42px;\n\tposition: absolute;\n\tleft: calc(50% - 26px);\n\tmargin: auto;\n\tborder-radius: 100%;\n\ttop: calc(50% - 26px);\n\tborder: 5px solid white;\n\tbox-sizing: content-box;\n}\n.vue-winwheel .canvas-wrapper:before {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 310px;\n\tbackground: #2A4D6F;\n\theight: 310px;\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\tmargin: 0 auto;\n\tborder-radius: 100%;\n\ttop: 0;\n}\n.vue-winwheel .wheel-wrapper {\n\tposition: relative;\n}\n.vue-winwheel .wheel-wrapper:before {\n\tcontent: '';\n\twidth: 62px;\n\theight: 47px;\n\tposition: absolute;\n\ttop: -10px;\n\tleft: calc(50% - 31px);\n\tright: 0;\n\tdisplay: block;\n\tz-index: 99999;\n\tbackground-image: url('../../../assets/flat-black-marker-2.png');\n\tbackground-repeat: no-repeat;\n\tbackground-size: contain;\n\tbackground-position: center;\n  filter: grayscale(60%);\n}\n.vue-winwheel .wheel-wrapper .button-wrapper {\n\tmargin: 0 auto;\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: center;\n\tjustify-content: center;\n\twidth: 231px;\n\theight: 118px;\n}\n.vue-winwheel .wheel-wrapper .btn.btn-play {\n\tpadding: 0 58px !important;\n\tbackground: #2A4D6F;\n\theight: 40px;\n\tline-height: 40px;\n\tcolor: white;\n\tfont-weight: bold;\n\ttext-decoration: none;\n\tborder-radius: 2px;\n\tfont-family: 'Avenir', Helvetica, Arial, sans-serif;\n\tletter-spacing: 2px;\n}\n</style>\n","import mod from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./WheelComponent.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./WheelComponent.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./WheelComponent.vue?vue&type=template&id=471fe322&scoped=true&\"\nimport script from \"./WheelComponent.vue?vue&type=script&lang=js&\"\nexport * from \"./WheelComponent.vue?vue&type=script&lang=js&\"\nimport style0 from \"./WheelComponent.vue?vue&type=style&index=0&id=471fe322&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"471fe322\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',[_c('div',{staticClass:\"w-full max-w-xs\"},[_c('form',{staticClass:\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\"},[_c('div',{staticClass:\"mb-4\"},[_c('label',{staticClass:\"block text-gray-700 text-sm font-bold mb-2\",attrs:{\"for\":\"username\"}},[_vm._v(\" Enregistrer un joueur \")]),_c('div',{staticClass:\"flex flex-row\"},[_c('div',{staticClass:\"basis-1/2\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.playersName),expression:\"playersName\"}],staticClass:\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\",attrs:{\"id\":\"username\",\"type\":\"text\",\"placeholder\":\"Nom du joueur\"},domProps:{\"value\":(_vm.playersName)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.playersName=$event.target.value}}})]),_c('div',{staticClass:\"basis-1/2\"},[_c('button',{staticClass:\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:bg-slate-50 disabled:text-slate-500 disabled:border-slate-200 disabled:shadow-none\",attrs:{\"disabled\":_vm.playersName === ''},on:{\"click\":function($event){$event.preventDefault();return _vm.handleSave()}}},[_vm._v(\" Enregistrer \")])])])])])]),_c('div',{staticClass:\"w-full max-w-xs \"},[_c('div',{staticClass:\"bg-white shadow-md max-h-80 rounded px-8 pt-6 pb-8 mb-4 overflow-auto\"},[_vm._m(0),_vm._l((_vm.players),function(player){return _c('div',{key:player.uniqId,staticClass:\"mb-4 pt-4 flex flex-col\"},[_c('div',{staticClass:\"flex flex-row justify-between items-start\"},[_c('div',[_vm._v(_vm._s(player.name))]),_c('div',[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(player.displayed),expression:\"player.displayed\"}],staticClass:\"form-check-input appearance-none h-4 w-4 border border-gray-300 rounded-sm bg-white checked:bg-blue-600 checked:border-blue-600 focus:outline-none transition duration-200 mt-1 align-top bg-no-repeat bg-center bg-contain float-left mr-2 cursor-pointer\",attrs:{\"type\":\"checkbox\"},domProps:{\"checked\":Array.isArray(player.displayed)?_vm._i(player.displayed,null)>-1:(player.displayed)},on:{\"click\":function($event){return _vm.handleDisplayedAttribute(player, !player.displayed)},\"change\":function($event){var $$a=player.displayed,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.$set(player, \"displayed\", $$a.concat([$$v])))}else{$$i>-1&&(_vm.$set(player, \"displayed\", $$a.slice(0,$$i).concat($$a.slice($$i+1))))}}else{_vm.$set(player, \"displayed\", $$c)}}}})]),_c('div',[_c('button',{staticClass:\"bg-pink-500 text-white active:bg-pink-600 font-bold uppercase text-xs px-4 py-2 rounded shadow hover:shadow-md outline-none focus:outline-none mr-1 mb-1 ease-linear transition-all duration-150\",on:{\"click\":function($event){$event.preventDefault();return _vm.deletePlayer(player)}}},[_vm._v(\" x \")])])])])})],2)])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"flex flex-row justify-between\"},[_c('div',[_vm._v(\"Name\")]),_c('div',[_vm._v(\"Afficher\")]),_c('div',[_vm._v(\"Supprimer\")])])}]\n\nexport { render, staticRenderFns }","<template>\n  <section>\n    <div class=\"w-full max-w-xs\">\n      <form class=\"bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4\">\n        <div class=\"mb-4\">\n          <label class=\"block text-gray-700 text-sm font-bold mb-2\" for=\"username\">\n            Enregistrer un joueur \n          </label>\n          <div class=\"flex flex-row\">\n            <div class=\"basis-1/2\">\n              <input\n                class=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" \n                id=\"username\" \n                type=\"text\" \n                placeholder=\"Nom du joueur\"\n                v-model=\"playersName\"\n              >\n            </div>\n            <div class=\"basis-1/2\">\n              <button\n                class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:bg-slate-50 disabled:text-slate-500 disabled:border-slate-200 disabled:shadow-none\"\n                :disabled=\"playersName === ''\"\n                @click.prevent=\"handleSave()\"\n              >\n                Enregistrer\n              </button>\n            </div>\n          </div>\n        </div>\n      </form>\n    </div>\n    <div class=\"w-full max-w-xs \">\n      <div class=\"bg-white shadow-md max-h-80 rounded px-8 pt-6 pb-8 mb-4 overflow-auto\">\n        <div class=\"flex flex-row justify-between\">\n          <div>Name</div>\n          <div>Afficher</div>\n          <div>Supprimer</div>\n        </div>\n        <div v-for=\"player in players\" :key=\"player.uniqId\" class=\"mb-4 pt-4 flex flex-col\">\n          <div class=\"flex flex-row justify-between items-start\">\n            <div>{{ player.name }}</div>\n            <div>\n              <input \n                class=\"form-check-input appearance-none h-4 w-4 border border-gray-300 rounded-sm bg-white checked:bg-blue-600 checked:border-blue-600 focus:outline-none transition duration-200 mt-1 align-top bg-no-repeat bg-center bg-contain float-left mr-2 cursor-pointer\"\n                type=\"checkbox\" \n                v-model=\"player.displayed\"\n                @click=\"handleDisplayedAttribute(player, !player.displayed)\"\n              >\n            </div>\n            <div>\n              <button\n                class=\"bg-pink-500 text-white active:bg-pink-600 font-bold uppercase text-xs px-4 py-2 rounded shadow hover:shadow-md outline-none focus:outline-none mr-1 mb-1 ease-linear transition-all duration-150\"\n                @click.prevent=\"deletePlayer(player)\"\n              >\n                x\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</template>\n\n\n<script>\n\nimport { mapState, mapMutations } from 'vuex';\n\nexport default {\n  name: 'NameChooser',\n  data () {\n    return {\n      playersName: '',\n    }\n  },\n  methods: {\n    ...mapMutations([\n      'ADD_PLAYERS',\n      'UPDATE_PLAYER',\n      'DELETE_PLAYER'],\n    ),\n    handleSave() {\n      const options = {\n        name: this.playersName,\n        displayed: true,\n      }\n      this.ADD_PLAYERS(options);\n      this.playersName = '';\n    },\n    handleDisplayedAttribute(player, value) {\n      player.displayed = value;\n      this.UPDATE_PLAYER(player);\n    },\n    deletePlayer(player) {\n      console.log(\"salut\");\n      this.DELETE_PLAYER(player);\n    },\n  },\n  computed: {\n    ...mapState(['players'])\n  },\n  watch: {\n\n  }\n}\n\n</script>\n\n<style scoped>\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./NameChooser.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./NameChooser.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./NameChooser.vue?vue&type=template&id=3a660715&scoped=true&\"\nimport script from \"./NameChooser.vue?vue&type=script&lang=js&\"\nexport * from \"./NameChooser.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"3a660715\",\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div id=\"app\">\n    <div class=\"flex flow-row justify-around\">\n      <div class=\"place-items-center px-8 pb-8 mb-4\">\n        <WheelComponent/>\n      </div>\n\n      <div class=\"place-items-center\">\n        <NameChooser/>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport WheelComponent from './Wheel/WheelComponent.vue'\nimport NameChooser from './NameChooser.vue'\n\nexport default {\n  name: 'GamesComponent',\n  data() {\n    return {\n\n    }\n  },\n  components: {\n    WheelComponent,\n    NameChooser\n  },\n  mounted() {\n\n  },\n  computed: {\n\n  },\n  methods: {\n\n  },\n  watch: {\n\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n\n.container {\n  display: flex;\n  justify-content: center;\n}\n</style>\n","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./GamesComponent.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./GamesComponent.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./GamesComponent.vue?vue&type=template&id=3fa95d65&\"\nimport script from \"./GamesComponent.vue?vue&type=script&lang=js&\"\nexport * from \"./GamesComponent.vue?vue&type=script&lang=js&\"\nimport style0 from \"./GamesComponent.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{staticClass:\"bg-white border-gray-200 px-2 sm:px-4 py-2.5 dark:bg-gray-800\"},[_c('div',{staticClass:\"container flex flex-wrap justify-between items-center mx-auto\"},[_vm._m(0),_c('div',{staticClass:\"flex md:order-2\"},[_c('button',{staticClass:\"text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center mr-3 md:mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800\",attrs:{\"type\":\"button\"}},[_vm._v(\"Go To Your Retro\")]),_c('button',{staticClass:\"inline-flex items-center p-2 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600\",attrs:{\"data-collapse-toggle\":\"mobile-menu-4\",\"type\":\"button\",\"aria-controls\":\"mobile-menu-4\",\"aria-expanded\":\"false\"}},[_c('span',{staticClass:\"sr-only\"},[_vm._v(\"Open main menu\")]),_c('svg',{staticClass:\"w-6 h-6\",attrs:{\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\"}},[_c('path',{attrs:{\"fill-rule\":\"evenodd\",\"d\":\"M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z\",\"clip-rule\":\"evenodd\"}})]),_c('svg',{staticClass:\"hidden w-6 h-6\",attrs:{\"fill\":\"currentColor\",\"viewBox\":\"0 0 20 20\",\"xmlns\":\"http://www.w3.org/2000/svg\"}},[_c('path',{attrs:{\"fill-rule\":\"evenodd\",\"d\":\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\",\"clip-rule\":\"evenodd\"}})])])]),_vm._m(1)])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',{staticClass:\"flex items-center\",attrs:{\"href\":\"https://flowbite.com\"}},[_c('span',{staticClass:\"self-center text-xl font-semibold whitespace-nowrap dark:text-white\"},[_vm._v(\"RetroWheel\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"hidden justify-between items-center w-full md:flex md:w-auto md:order-1\",attrs:{\"id\":\"mobile-menu-4\"}},[_c('ul',{staticClass:\"flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium\"},[_c('li',[_c('a',{staticClass:\"block py-2 pr-4 pl-3 text-white bg-blue-700 rounded md:bg-transparent md:text-blue-700 md:p-0 dark:text-white\",attrs:{\"href\":\"#\",\"aria-current\":\"page\"}},[_vm._v(\"Home\")])]),_c('li',[_c('a',{staticClass:\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\",attrs:{\"href\":\"#\"}},[_vm._v(\"About\")])]),_c('li',[_c('a',{staticClass:\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\",attrs:{\"href\":\"#\"}},[_vm._v(\"Services\")])]),_c('li',[_c('a',{staticClass:\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\",attrs:{\"href\":\"#\"}},[_vm._v(\"Contact\")])])])])}]\n\nexport { render, staticRenderFns }","<template>\n  <nav class=\"bg-white border-gray-200 px-2 sm:px-4 py-2.5 dark:bg-gray-800\">\n    <div class=\"container flex flex-wrap justify-between items-center mx-auto\">\n      <a href=\"https://flowbite.com\" class=\"flex items-center\">\n        <span class=\"self-center text-xl font-semibold whitespace-nowrap dark:text-white\">RetroWheel</span>\n      </a>\n      <div class=\"flex md:order-2\">\n        <button type=\"button\" class=\"text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center mr-3 md:mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800\">Go To Your Retro</button>\n        <button data-collapse-toggle=\"mobile-menu-4\" type=\"button\" class=\"inline-flex items-center p-2 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600\" aria-controls=\"mobile-menu-4\" aria-expanded=\"false\">\n          <span class=\"sr-only\">Open main menu</span>\n          <svg class=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z\" clip-rule=\"evenodd\"></path></svg>\n          <svg class=\"hidden w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path></svg>\n        </button>\n      </div>\n      <div class=\"hidden justify-between items-center w-full md:flex md:w-auto md:order-1\" id=\"mobile-menu-4\">\n        <ul class=\"flex flex-col mt-4 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium\">\n          <li>\n            <a href=\"#\" class=\"block py-2 pr-4 pl-3 text-white bg-blue-700 rounded md:bg-transparent md:text-blue-700 md:p-0 dark:text-white\" aria-current=\"page\">Home</a>\n          </li>\n          <li>\n            <a href=\"#\" class=\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\">About</a>\n          </li>\n          <li>\n            <a href=\"#\" class=\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\">Services</a>\n          </li>\n          <li>\n            <a href=\"#\" class=\"block py-2 pr-4 pl-3 text-gray-700 border-b border-gray-100 hover:bg-gray-50 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 md:dark:hover:text-white dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent dark:border-gray-700\">Contact</a>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </nav>\n</template>\n\n<script>\nexport default {\n  name: 'NavbarComponent',\n}\n</script>\n\n<style scoped>\n\n</style>\n","import mod from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./NavbarComponent.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./NavbarComponent.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./NavbarComponent.vue?vue&type=template&id=6563c32a&scoped=true&\"\nimport script from \"./NavbarComponent.vue?vue&type=script&lang=js&\"\nexport * from \"./NavbarComponent.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"6563c32a\",\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div>\n    <NavbarComponent/>\n\n    <div id=\"app\">\n      <GamesComponent/>\n    </div>\n  </div>\n</template>\n\n<script>\nimport GamesComponent from './components/Games/GamesComponent';\nimport NavbarComponent from './components/NavbarComponent.vue';\nexport default {\n  name: 'App',\n  components: {\n    GamesComponent,\n    NavbarComponent\n  }\n}\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n</style>\n","import mod from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-40[0].rules[0].use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=313e243d&\"\nimport script from \"./App.vue?vue&type=script&lang=js&\"\nexport * from \"./App.vue?vue&type=script&lang=js&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst state = {\n  players: [],\n}\n\nconst mutations = {\n  ADD_PLAYERS (state, value) {\n    const uniqId = Date.now();\n    const player = {\n      uniqId,\n      name: value.name,\n      displayed: value.displayed,\n    }\n    state.players.push(player);\n  },\n\n  UPDATE_PLAYER (state, player) {\n    const playerIndex = state.players\n      .findIndex(statePlayer => statePlayer.uniqId === player.uniqId)\n    state.players.splice(playerIndex, 1, player)\n  },\n\n  DELETE_PLAYER (state, player) {\n    const playerIndex = state.players\n      .findIndex(statePlayer => statePlayer.uniqId === player.uniqId)\n    state.players.splice(playerIndex, 1);\n  }\n}\n\nexport default new Vuex.Store({\n  state,\n  mutations\n})\n","import Vue from 'vue';\nimport VueRouter from 'vue-router';\n\nVue.use(VueRouter);\n\nimport App from './App';\nimport GamesComponent from './components/Games/GamesComponent'\n\nconst router = new VueRouter({\n  mode: 'history',\n  base: __dirname,\n  routes: [\n    { path: '/', component: App},\n    { path: '/choose', component: GamesComponent }\n  ]\n});\n\nexport default router;\n","import Vue from 'vue'\nimport App from './App.vue'\nimport store from './store/store'\nimport router from './router'\nimport './index.css'\nimport 'flowbite';\n\nVue.config.productionTip = false\n\nnew Vue({\n  el: '#app',\n  router,\n  store,\n  template: '<App/>',\n  components: { App }\n})\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = function(module) {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: function() {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t143: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkretro_picker\"] = self[\"webpackChunkretro_picker\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [998], function() { return __webpack_require__(2419); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["Winwheel","options","drawWheel","defaultOptions","canvasId","centerX","centerY","outerRadius","innerRadius","numSegments","drawMode","rotationAngle","textFontFamily","textFontSize","textFontWeight","textOrientation","textAlignment","textDirection","textMargin","textFillStyle","textStrokeStyle","textLineWidth","fillStyle","strokeStyle","lineWidth","clearTheCanvas","imageOverlay","drawText","pointerAngle","wheelImage","imageDirection","key","this","canvas","document","getElementById","width","height","ctx","getContext","cavnas","segments","Array","x","Segment","updateSegmentSizes","animation","Animation","pins","Pin","pointerGuide","PointerGuide","draw","winwheelToDrawDuringAnimation","winhweelAlreadyDrawn","y","image","imgData","Image","onload","winwheelLoadedImage","src","arcUsed","numSet","size","arcLeft","degreesEach","currentDegree","startAngle","endAngle","clearRect","clearCanvas","drawWheelImage","drawSegmentText","drawSegments","drawSegmentImages","visible","drawPins","display","drawPointerGuide","number","pinSpacing","i","save","translate","rotate","degToRad","beginPath","arc","margin","Math","PI","fill","stroke","restore","moveTo","lineTo","imageLeft","imageTop","drawImage","seg","imageAngle","console","log","fontFamily","fontSize","fontWeight","orientation","alignment","direction","fontSetting","text","font","lines","split","lineOffset","length","textAlign","textBaseline","textAngle","fillText","strokeText","yPos","yInc","c","character","charAt","centerAdjustment","radius","anglePerChar","drawAngle","radiusPercent","totalArc","d","position","segmentPos","newSegment","undefined","bbox","getBoundingClientRect","floor","left","top","foundSegment","segmentNumber","getSegmentNumberAt","topBottom","leftRight","adjacentSideLength","oppositeSideLength","hypotenuseSideLength","loc","windowToCanvas","tanVal","result","atan","locationAngle","sqrt","round","rotatedPosition","getRotationPosition","abs","foundSegmentNumber","prizeNumber","getIndicatedSegmentNumber","indicatedPrize","rawAngle","relativeAngle","currentPin","totalPinAngle","timesPast360","ceil","computeAnimation","properties","propertyName","propertyValue","yoyo","repeat","easing","winwheelAnimationLoop","winwheelStopAnimation","tween","TweenMax","duration","canCallback","kill","pause","play","type","spins","stopAngle","_stopAngle","random","range","callbackFinished","callbackBefore","callbackAfter","callbackSound","soundTrigger","winwheelPercentToDegrees","percentValue","degrees","divider","eval","winwheelTriggerSound","hasOwnProperty","_lastSoundTriggerNumber","currentTriggerNumber","getCurrentPinNumber","callback","getIndicatedSegment","winwheelImageLoadCount","render","_vm","_h","$createElement","_c","_self","attrs","staticRenderFns","staticClass","formattedPlayers","_m","loadingPrize","wheelSpinning","_e","on","$event","preventDefault","startSpin","_v","slot","hidePrize","_s","prizeName","staticStyle","name","data","theWheel","winningPlayer","WinWheelOptions","outterRadius","methods","showPrize","formatColors","index","desiredIndex","resetWheel","initSpin","onFinishSpin","indicatedSegment","playSound","computed","mapState","filter","map","uniqId","displayed","watch","mounted","component","directives","rawName","value","expression","domProps","target","composing","playersName","handleSave","_l","player","isArray","_i","handleDisplayedAttribute","$$a","$$el","$$c","checked","$$v","$$i","$set","concat","slice","deletePlayer","mapMutations","components","WheelComponent","NameChooser","GamesComponent","NavbarComponent","Vue","Vuex","state","players","mutations","ADD_PLAYERS","Date","now","push","UPDATE_PLAYER","playerIndex","findIndex","statePlayer","splice","DELETE_PLAYER","VueRouter","router","mode","base","__dirname","routes","path","App","el","store","template","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","m","deferred","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","r","n","getter","__esModule","a","definition","o","defineProperty","enumerable","get","g","globalThis","Function","e","window","hmd","create","children","set","Error","obj","prop","prototype","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}